<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>å•è¯å¤ä¹ æœ¬ Pro v20 (AI Struct)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- å¼•å…¥æ ¸å¿ƒåº“ -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Tailwind Configuration -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        dark: {
                            bg: '#0f172a',      // slate-900
                            card: '#1e293b',    // slate-800
                            text: '#f1f5f9',    // slate-100
                            subtext: '#94a3b8', // slate-400
                            input: '#334155'    // slate-700
                        }
                    },
                    animation: {
                        'shake': 'shake 0.5s cubic-bezier(.36,.07,.19,.97) both',
                        'pop': 'pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards',
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    },
                    keyframes: {
                        shake: {
                            '0%, 100%': { transform: 'translateX(0)' },
                            '10%, 30%, 50%, 70%, 90%': { transform: 'translateX(-4px)' },
                            '20%, 40%, 60%, 80%': { transform: 'translateX(4px)' },
                        },
                        pop: {
                            '0%': { transform: 'scale(0.9)', opacity: 0 },
                            '100%': { transform: 'scale(1)', opacity: 1 },
                        }
                    }
                }
            }
        }
    </script>
    
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
            -webkit-tap-highlight-color: transparent; 
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        textarea { resize: none; }
        .font-phonetic { font-family: "Times New Roman", serif; }
        
        @keyframes blob {
            0% { transform: translate(0px, 0px) scale(1); }
            33% { transform: translate(30px, -50px) scale(1.1); }
            66% { transform: translate(-20px, 20px) scale(0.9); }
            100% { transform: translate(0px, 0px) scale(1); }
        }
        .animate-blob { animation: blob 7s infinite; }
        .animation-delay-2000 { animation-delay: 2s; }
        .animation-delay-4000 { animation-delay: 4s; }
        
        .glass-card {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1);
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }
        
        .dark .glass-card {
            background: rgba(30, 41, 59, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
        }

        .phonetic-card { transition: all 0.2s; }
        .phonetic-card:active { transform: scale(0.95); }
        
        @keyframes slide-down {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-slide-down { animation: slide-down 0.2s ease-out; }
    </style>
</head>
<body class="bg-slate-50 dark:bg-slate-900 min-h-screen overscroll-none text-slate-800 dark:text-slate-100 transition-colors duration-300">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // ==========================================
        // 1. AI Service (DeepSeek)
        // ==========================================
        const callDeepSeek = async (apiKey, word, contextNote) => {
            const url = "https://api.deepseek.com/chat/completions";
            const prompt = `
            I am learning English words.
            Target Word: "${word}"
            My Current Note (Context): "${contextNote || "No context provided."}"

            Please perform the following tasks and output strictly in JSON format:
            1. "analysis": Analyze the sentences in my note. If a sentence is missing a Chinese translation, provide it. Also, explain the specific meaning of "${word}" in that sentence. Answer in Chinese.
            2. "new_example": Generate ONE new, high-quality example sentence using "${word}" that is different from the note, including its Chinese translation.

            JSON Format Requirement:
            {
                "analysis": [
                    { "sentence": "The English sentence from note", "translation": "Chinese translation", "word_meaning": "Meaning of '${word}' here" }
                ],
                "new_example": {
                    "sentence": "New English sentence",
                    "translation": "Chinese translation"
                }
            }
            If the note contains multiple sentences, analyze each one in the "analysis" array. If the note is empty, leave "analysis" empty.
            `;

            try {
                const response = await fetch(url, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "deepseek-chat",
                        messages: [
                            { role: "system", content: "You are a helpful English vocabulary tutor. You always respond with valid JSON." },
                            { role: "user", content: prompt }
                        ],
                        response_format: { type: "json_object" }
                    })
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.error?.message || "API Request Failed");
                }

                const data = await response.json();
                const content = data.choices[0].message.content;
                return JSON.parse(content);
            } catch (error) {
                console.error("AI Error:", error);
                throw error;
            }
        };

        // ==========================================
        // 2. Icons & UI Components
        // ==========================================
        const IconBase = ({ children, size = 18, className = "", ...props }) => (<svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>);
        
        const Icons = {
            BookOpen: (p) => <IconBase {...p}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></IconBase>,
            Check: (p) => <IconBase {...p}><polyline points="20 6 9 17 4 12"/></IconBase>,
            X: (p) => <IconBase {...p}><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></IconBase>,
            Plus: (p) => <IconBase {...p}><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></IconBase>,
            Trash2: (p) => <IconBase {...p}><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2-2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></IconBase>,
            Upload: (p) => <IconBase {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></IconBase>,
            Download: (p) => <IconBase {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></IconBase>,
            List: (p) => <IconBase {...p}><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></IconBase>,
            Volume2: (p) => <IconBase {...p}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></IconBase>,
            Edit3: (p) => <IconBase {...p}><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></IconBase>,
            ArrowRight: (p) => <IconBase {...p}><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></IconBase>,
            Shuffle: (p) => <IconBase {...p}><polyline points="16 3 21 3 21 8"/><line x1="4" y1="20" x2="21" y2="3"/><polyline points="21 16 21 21 16 21"/><line x1="15" y1="15" x2="21" y2="21"/><line x1="4" y1="4" x2="9" y2="9"/></IconBase>,
            Star: (p) => <IconBase {...p}><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></IconBase>,
            Eye: (p) => <IconBase {...p}><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></IconBase>,
            FileText: (p) => <IconBase {...p}><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></IconBase>,
            Link: (p) => <IconBase {...p}><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></IconBase>,
            Wand2: (p) => <IconBase {...p}><path d="m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72Z"/><path d="m14 7 3 3"/><path d="M5 6v4"/><path d="M19 14v4"/><path d="M10 2v2"/><path d="M7 8H3"/><path d="M21 16h-4"/><path d="M11 3H9"/></IconBase>,
            Archive: (p) => <IconBase {...p}><polyline points="21 8 21 21 3 21 3 8"/><rect x="1" y="3" width="22" height="5"/><line x1="10" y1="12" x2="14" y2="12"/></IconBase>,
            Globe: (p) => <IconBase {...p}><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></IconBase>,
            PenTool: (p) => <IconBase {...p}><path d="m12 19 7-7 3 3-7 7-3-3z"/><path d="m18 13-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="m2 2 7.586 7.586"/><circle cx="11" cy="11" r="2"/></IconBase>,
            HelpCircle: (p) => <IconBase {...p}><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></IconBase>,
            SortAsc: (p) => <IconBase {...p}><path d="m11 16 4 4 4-4"/><path d="M15 20V4"/><path d="M4 19h5"/><path d="M4 15h6"/><path d="M4 11h8"/><path d="M4 7h4"/></IconBase>,
            SortDesc: (p) => <IconBase {...p}><path d="m11 8 4-4 4 4"/><path d="M15 4v16"/><path d="M4 19h4"/><path d="M4 15h8"/><path d="M4 11h6"/><path d="M4 7h5"/></IconBase>,
            SortList: (p) => <IconBase {...p}><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></IconBase>,
            ChevronDown: (p) => <IconBase {...p}><path d="m6 9 6 6 6-6"/></IconBase>,
            Moon: (p) => <IconBase {...p}><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></IconBase>,
            Sun: (p) => <IconBase {...p}><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></IconBase>,
            Split: (p) => <IconBase {...p}><line x1="8" y1="3" x2="8" y2="21"/><line x1="16" y1="3" x2="16" y2="21"/><line x1="2" y1="12" x2="22" y2="12"/></IconBase>,
            Game: (p) => <IconBase {...p}><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/><polygon points="10 8 16 12 10 16 10 8"/></IconBase>,
            Settings: (p) => <IconBase {...p}><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></IconBase>,
            Sparkles: (p) => <IconBase {...p}><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 21l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/></IconBase>,
            Key: (p) => <IconBase {...p}><path d="m21 2-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0 3 3L22 7l-3-3m-3.5 3.5L19 4"/></IconBase>
        };

        const Toast = ({ msg, type, onClose }) => {
            useEffect(() => { const t = setTimeout(onClose, 2000); return () => clearTimeout(t); }, []);
            const bg = type === 'success' ? 'bg-green-500' : type === 'error' ? 'bg-red-500' : 'bg-gray-800';
            return <div className={`fixed top-4 left-1/2 -translate-x-1/2 z-50 px-4 py-2 rounded-full shadow-lg text-white text-sm font-bold ${bg} animate-slide-down`}>{msg}</div>;
        };

        const GlassButton = ({ onClick, active, iconName, label, className = "" }) => {
            const Icon = Icons[iconName];
            return (
                <button onClick={onClick} className={`flex items-center justify-center px-3 py-2 rounded-xl transition-all duration-300 font-medium text-xs sm:text-sm whitespace-nowrap flex-shrink-0 focus:outline-none focus:ring-2 focus:ring-indigo-500/50 ${active ? 'bg-indigo-600/90 text-white shadow-lg shadow-indigo-500/30' : 'bg-white/50 dark:bg-slate-700/50 text-gray-600 dark:text-gray-300 hover:bg-white/80 dark:hover:bg-slate-700 hover:text-indigo-600 dark:hover:text-white'} ${className}`}>
                    {Icon && <Icon size={16} className={label ? "mr-1" : ""} />} {label}
                </button>
            );
        };

        const SortMenu = ({ sortMode, setSortMode, t }) => {
            const [isOpen, setIsOpen] = useState(false);
            const menuRef = useRef(null);
            useEffect(() => {
                const handleClickOutside = (event) => { if (menuRef.current && !menuRef.current.contains(event.target)) setIsOpen(false); };
                document.addEventListener("mousedown", handleClickOutside);
                return () => document.removeEventListener("mousedown", handleClickOutside);
            }, []);
            const options = [{ id: 'default', label: t.sort_default, icon: 'SortList' }, { id: 'az', label: t.sort_az, icon: 'SortAsc' }, { id: 'za', label: t.sort_za, icon: 'SortDesc' }, { id: 'random', label: t.sort_random, icon: 'Shuffle' }];
            const activeOption = options.find(o => o.id === sortMode) || options[0];
            const ActiveIcon = Icons[activeOption.icon];
            return (
                <div className="relative" ref={menuRef}>
                    <button onClick={() => setIsOpen(!isOpen)} className="flex items-center bg-gray-100 dark:bg-slate-700 px-2 py-1 rounded-lg text-xs font-medium text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-slate-600 transition"><ActiveIcon size={14} className="mr-1" /><span className="mr-1 hidden sm:inline">{activeOption.label}</span><Icons.ChevronDown size={12} /></button>
                    {isOpen && (<div className="absolute top-full left-0 mt-1 w-32 bg-white dark:bg-slate-800 rounded-xl shadow-xl border border-gray-100 dark:border-slate-700 z-30 overflow-hidden animate-slide-down">{options.map(opt => { const OptIcon = Icons[opt.icon]; return (<button key={opt.id} onClick={() => { setSortMode(opt.id); setIsOpen(false); }} className={`w-full text-left px-4 py-3 text-xs font-medium flex items-center hover:bg-gray-50 dark:hover:bg-slate-700 transition ${sortMode === opt.id ? 'text-indigo-600 dark:text-indigo-400 bg-indigo-50 dark:bg-slate-700' : 'text-gray-600 dark:text-gray-400'}`}><OptIcon size={14} className="mr-2" />{opt.label}</button>); })}</div>)}
                </div>
            );
        };

        const SettingsModal = ({ isOpen, onClose, apiKey, setApiKey }) => {
            const [val, setVal] = useState(apiKey);
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-gray-900/60 backdrop-blur-sm" onClick={onClose}>
                    <div className="bg-white dark:bg-slate-800 rounded-3xl shadow-2xl w-full max-w-md p-6 transition-colors" onClick={e => e.stopPropagation()}>
                        <h3 className="text-lg font-bold text-gray-800 dark:text-white mb-4 flex items-center"><Icons.Settings size={20} className="mr-2 text-indigo-500"/> Settings</h3>
                        <div className="mb-4">
                            <label className="block text-xs font-bold text-gray-500 dark:text-gray-400 uppercase mb-2">DeepSeek API Key</label>
                            <div className="relative"><Icons.Key className="absolute left-3 top-3 text-gray-400" size={16}/><input type="password" value={val} onChange={e => setVal(e.target.value)} className="w-full pl-10 pr-3 py-2.5 border rounded-xl bg-gray-50 dark:bg-slate-700/50 border-gray-200 dark:border-slate-600 text-gray-800 dark:text-gray-100 focus:border-indigo-500 focus:outline-none text-sm" placeholder="sk-..." /></div>
                            <div className="mt-2 text-[10px] text-gray-400">Keys are stored locally in your browser.</div>
                        </div>
                        <div className="flex justify-end space-x-3"><button onClick={onClose} className="px-4 py-2 text-sm font-bold text-gray-500 hover:bg-gray-100 dark:hover:bg-slate-700 rounded-lg transition">Cancel</button><button onClick={() => { setApiKey(val); onClose(); }} className="px-4 py-2 text-sm font-bold bg-indigo-600 text-white rounded-lg shadow hover:bg-indigo-700 transition">Save</button></div>
                    </div>
                </div>
            );
        };

        const PHONETIC_DATA = { vowels: { title: "å…ƒéŸ³ (Vowels)", color: "text-blue-600 dark:text-blue-400", bg: "bg-blue-50 dark:bg-blue-900/30", groups: [ { name: "å•å…ƒéŸ³", items: [{ symbol: "[iË]", sound: "è¡£", tip: "é•¿éŸ³, å˜´è§’æ‹‰å¼€" }, { symbol: "[Éª]", sound: "è¡£", tip: "çŸ­æ€¥" }, { symbol: "[e]", sound: "å“", tip: "å°å£" }, { symbol: "[Ã¦]", sound: "å“", tip: "å¤§å£æ¢…èŠ±" }, { symbol: "[ÉœË]", sound: "é¥¿", tip: "é•¿å·èˆŒ" }, { symbol: "[É™]", sound: "é¥¿", tip: "çŸ­è½»" }, { symbol: "[ÊŒ]", sound: "å•Š", tip: "çŸ­ä¿ƒ" }, { symbol: "[uË]", sound: "ä¹Œ", tip: "é•¿åœ†å”‡" }, { symbol: "[ÊŠ]", sound: "ä¹Œ", tip: "çŸ­æ”¾æ¾" }, { symbol: "[É”Ë]", sound: "å—·", tip: "é•¿éŸ³" }, { symbol: "[É’]", sound: "å—·", tip: "çŸ­å¤§å£" }, { symbol: "[É‘Ë]", sound: "å•Š", tip: "é•¿å¼ å˜´" }] }, { name: "åŒå…ƒéŸ³", items: [{ symbol: "[eÉª]", sound: "A", tip: "å­—æ¯A" }, { symbol: "[aÉª]", sound: "çˆ±", tip: "æ»‘å‘å°å£" }, { symbol: "[É”Éª]", sound: "å¥¥ä¸€", tip: "boyå°¾éŸ³" }, { symbol: "[É™ÊŠ]", sound: "æ¬§", tip: "goå‘éŸ³" }, { symbol: "[aÊŠ]", sound: "å¥¥å‘œ", tip: "ç‹¼å«" }, { symbol: "[ÉªÉ™]", sound: "è¡£é¥¿", tip: "ear" }, { symbol: "[eÉ™]", sound: "å“é¥¿", tip: "air" }, { symbol: "[ÊŠÉ™]", sound: "ä¹Œé¥¿", tip: "tour" }] } ] }, consonants: { title: "è¾…éŸ³ (Consonants)", color: "text-emerald-600 dark:text-emerald-400", bg: "bg-emerald-50 dark:bg-emerald-900/30", groups: [ { name: "æ¸…è¾…éŸ³", items: [{ symbol: "[p]", sound: "æ³¼", tip: "å–·æ°”" }, { symbol: "[t]", sound: "ç‰¹", tip: "æŠµä¸Šé½¿" }, { symbol: "[k]", sound: "å—‘", tip: "åƒå’³å—½" }, { symbol: "[f]", sound: "æ‰¶", tip: "å’¬ä¸‹å”‡" }, { symbol: "[s]", sound: "å˜¶", tip: "è›‡åä¿¡" }, { symbol: "[Î¸]", sound: "å˜¶", tip: "å’¬èˆŒå°–" }, { symbol: "[Êƒ]", sound: "ç‹®", tip: "å˜˜å£°" }, { symbol: "[tÊƒ]", sound: "åƒ", tip: "çŸ­ä¿ƒ" }, { symbol: "[tr]", sound: "æˆ³", tip: "åœ†å”‡" }, { symbol: "[ts]", sound: "å‘²", tip: "åƒæ¬¡" }, { symbol: "[h]", sound: "å–", tip: "å“ˆæ°”" }] }, { name: "æµŠè¾…éŸ³", items: [{ symbol: "[b]", sound: "ä¼¯", tip: "çŸ­ä¿ƒ" }, { symbol: "[d]", sound: "å¾·", tip: "çŸ­ä¿ƒ" }, { symbol: "[g]", sound: "å“¥", tip: "çŸ­ä¿ƒ" }, { symbol: "[v]", sound: "è–‡", tip: "å’¬å”‡éœ‡åŠ¨" }, { symbol: "[z]", sound: "å—", tip: "èœœèœ‚" }, { symbol: "[Ã°]", sound: "å—", tip: "å’¬èˆŒéœ‡åŠ¨" }, { symbol: "[Ê’]", sound: "æ—¥", tip: "å·èˆŒ" }, { symbol: "[dÊ’]", sound: "æ", tip: "çŸ­ä¿ƒ" }, { symbol: "[dr]", sound: "æ‰", tip: "åœ†å”‡" }, { symbol: "[dz]", sound: "å­", tip: "éœ‡åŠ¨" }, { symbol: "[r]", sound: "å¼±", tip: "å·èˆŒ" }, { symbol: "[m]", sound: "æ‘¸", tip: "é—­å˜´" }, { symbol: "[n]", sound: "å‘¢", tip: "å¼ å˜´" }, { symbol: "[Å‹]", sound: "å—¯", tip: "åé¼»éŸ³" }, { symbol: "[l]", sound: "ä¹", tip: "æŠµä¸Šé¢š" }, { symbol: "[j]", sound: "çˆ·", tip: "yeså¤´" }, { symbol: "[w]", sound: "æˆ‘", tip: "åœ†å”‡" }] } ] } };
        const DEMO_DATA = [
            { id: 1, word: "taught", translation: "v. æ•™æˆ (teach çš„è¿‡å»åˆ†è¯)", phonetic: "è‹± [tÉ”Ët] ç¾ [tÉ”Ët]", mastered: false, isFavorite: false, archived: false, stats: { correct: 0, wrong: 0 }, note: `Eason Chan only <b>taught</b> me how to sing ten years, but did not teach me how to go for ten years.\né™ˆå¥•è¿…åªæ•™ç»™æˆ‘åå¹´æ€ä¹ˆå”±ï¼Œå´æ²¡æ•™ç»™æˆ‘åå¹´æ€ä¹ˆèµ°ã€‚\n\nMy uncle <b>taught</b> me to juggle.\næˆ‘å”å”æ•™æˆ‘ç©æ‚è€ã€‚\n\nMy mother <b>taught</b> me how to sew.\næˆ‘æ¯äº²æ•™æˆ‘åšé’ˆçº¿ã€‚`, source: "Lyrics", keyMeaning: "v. æ•™æˆ" },
            { id: 2, word: "unique", translation: "adj. ç‹¬ä¸€æ— äºŒçš„ï¼Œç‹¬ç‰¹çš„ï¼›éå¸¸ç‰¹åˆ«çš„", phonetic: "è‹± [juËˆniËk]", mastered: false, isFavorite: true, archived: false, stats: { correct: 0, wrong: 0 }, note: "You are unique.", source: "Demo", keyMeaning: "adj. ç‹¬ä¸€æ— äºŒçš„" }
        ];

        const I18N = {
            zh: { title: "å•è¯å¤ä¹ æœ¬", browse: "æµè§ˆ", spelling: "æ‹¼å†™", list: "ç®¡ç†", import: "å¯¼å…¥", phonetic_table: "æ‹ŸéŸ³", active: "å­¦ä¹ ä¸­", archived: "å·²å½’æ¡£", empty_browse: "æ­å–œï¼æ²¡æœ‰å¾…å¤ä¹ çš„å•è¯", empty_spelling: "åˆ—è¡¨ä¸ºç©º", no_phonetic: "æ— éŸ³æ ‡", auto_phonetic: "è¡¥å…¨", fetching: "è·å–ä¸­...", clear_all: "æ¸…ç©º", import_title: "å¯¼å…¥æ•°æ®", import_click: "ä¸Šä¼ æ–‡ä»¶", import_desc: "æ”¯æŒ Excel/TXT", import_ph: "åœ¨æ­¤ç²˜è´´...", import_btn: "å¼€å§‹å¯¼å…¥", import_success: (n) => `æˆåŠŸå¯¼å…¥ ${n} ä¸ªå•è¯ï¼`, import_fail: "æ— æ³•è¯†åˆ«", spelling_setup: "æ‹¼å†™é…ç½®", scope: "èŒƒå›´", scope_all: "å…¨éƒ¨", scope_fav: "æ”¶è—", scope_new: "æœªæŒæ¡", mode: "é¡ºåº", mode_random: "éšæœº", mode_seq: "é¡ºåº", hint: "æç¤º", hint_copy: "æŠ„å†™", hint_blind: "é»˜å†™", count: "æ•°é‡", count_all: "å…¨éƒ¨", start: "å¼€å§‹æŒ‘æˆ˜", result: "æŒ‘æˆ˜å®Œæˆ", correct: "æ­£ç¡®", wrong: "é”™è¯¯", back_setup: "è¿”å›é…ç½®", translate_this: "è¯·æ‹¼å†™", type_ph: "è¾“å…¥å•è¯...", press_enter_check: "æŒ‰ Enter æ£€æŸ¥", press_enter_next: "æŒ‰ Enter ç»§ç»­", try_again: "å†è¯•ä¸€æ¬¡", archive_btn: "å½’æ¡£", unarchive_btn: "æ¢å¤", source: "æ¥æº", note: "ç¬”è®°", key_meaning: "åŠ©è®°", quick_pick: "æç‚¼:", pos_label: "è¯æ€§", export_btn: "å¯¼å‡º", phonetic_help: "æ‹ŸéŸ³è¡¨", sort: "æ’åº", sort_default: "é»˜è®¤", sort_az: "A-Z", sort_za: "Z-A", sort_random: "éšæœº", syllable_mode: "éŸ³èŠ‚æ¨¡å¼", spelling_mode: "æ¨¡å¼", spelling_scope: "èŒƒå›´", spelling_count: "é¢˜é‡", spelling_hint: "æç¤º", peek: "æŒ‰ä½çœ‹è¯", import_check: "åˆ†æå†…å®¹", import_confirm: "ç¡®è®¤å¯¼å…¥", ai_analyze: "AI è§£æ", ai_analyzing: "è§£æä¸­...", ai_no_key: "è¯·å…ˆé…ç½® API Key", ai_save: "ä¿å­˜", ai_saved: "å·²ä¿å­˜", ai_analysis_title: "AI æ·±åº¦è§£æ", import_exclude: "æ’é™¤å·²å­˜åœ¨å•è¯ (æ ¹æ®æ‹¼å†™)" },
            en: { title: "Word Review", browse: "Browse", spelling: "Spelling", list: "Manage", import: "Import", phonetic_table: "Phonetics", active: "Active", archived: "Archived", empty_browse: "No words", empty_spelling: "No words", no_phonetic: "No Phonetic", auto_phonetic: "Auto", fetching: "...", clear_all: "Clear", import_title: "Import", import_click: "Upload", import_desc: "Excel/TXT", import_ph: "Paste here...", import_btn: "Import", import_success: (n) => `Added ${n} words!`, import_fail: "Failed", spelling_setup: "Setup", scope: "Scope", scope_all: "All", scope_fav: "Favs", scope_new: "New", mode: "Order", mode_random: "Random", mode_seq: "Seq", hint: "Hint", hint_copy: "Copy", hint_blind: "Blind", count: "Count", count_all: "All", start: "Start Challenge", result: "Done", correct: "Correct", wrong: "Wrong", back_setup: "Back", translate_this: "SPELL IT", type_ph: "Type word...", press_enter_check: "Enter to Check", press_enter_next: "Enter to Next", try_again: "Try again", archive_btn: "Archive", unarchive_btn: "Restore", source: "Source", note: "Note", key_meaning: "Memo", quick_pick: "Pick:", pos_label: "POS", export_btn: "Export", phonetic_help: "Table", sort: "Sort", sort_default: "Default", sort_az: "A-Z", sort_za: "Z-A", sort_random: "Shuffle", syllable_mode: "Syllables", spelling_mode: "Mode", spelling_scope: "Scope", spelling_count: "Count", spelling_hint: "Hint", peek: "Hold to Peek", import_check: "Analyze", import_confirm: "Confirm Import", ai_analyze: "AI Analyze", ai_analyzing: "Thinking...", ai_no_key: "Set API Key First", ai_save: "Save", ai_saved: "Saved", ai_analysis_title: "AI Analysis", import_exclude: "Exclude Existing Words" }
        };

        const PhoneticModal = ({ isOpen, onClose }) => {
            if (!isOpen) return null;
            const CategorySection = ({ title, groups, color, bg }) => ( <div className={`rounded-2xl border border-gray-100 dark:border-slate-700 overflow-hidden flex flex-col h-full shadow-sm`}><div className={`${bg} px-4 py-3 font-bold ${color} border-b border-gray-100 dark:border-slate-700 flex items-center`}>{title}</div><div className="p-4 bg-white/80 dark:bg-slate-800/80 flex-1 overflow-y-auto space-y-4">{groups.map((group, idx) => (<div key={idx}><div className="text-xs font-bold text-gray-400 dark:text-gray-500 mb-2 uppercase tracking-wider">{group.name}</div><div className="grid grid-cols-3 sm:grid-cols-3 gap-2">{group.items.map((item, i) => (<div key={i} className="phonetic-card p-1.5 rounded-lg bg-gray-50 dark:bg-slate-700/50 border border-gray-100 dark:border-slate-600 flex flex-col items-center justify-center text-center hover:bg-white dark:hover:bg-slate-600 shadow-sm transition-colors"><div className={`symbol-text text-base font-bold ${color} mb-0.5`}>{item.symbol}</div><div className="text-xs font-bold text-gray-700 dark:text-gray-300">{item.sound}</div>{item.tip && <div className="text-[10px] text-gray-400 scale-90 origin-top truncate w-full">{item.tip}</div>}</div>))}</div></div>))}</div></div> );
            return ( <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-gray-900/60 backdrop-blur-sm" onClick={onClose}><div className="bg-white dark:bg-slate-800 rounded-3xl shadow-2xl w-full max-w-5xl max-h-[90vh] flex flex-col overflow-hidden transition-colors" onClick={e => e.stopPropagation()}><div className="p-4 border-b border-gray-100 dark:border-slate-700 flex justify-between items-center bg-white dark:bg-slate-800 z-10 shrink-0"><h3 className="text-lg font-bold text-gray-800 dark:text-white flex items-center"><span className="w-8 h-8 rounded-full bg-indigo-100 dark:bg-indigo-900 text-indigo-600 dark:text-indigo-300 flex items-center justify-center mr-2"><span className="font-phonetic text-lg">É™</span></span> {window.innerWidth < 640 ? "æ‹ŸéŸ³è¡¨" : "éŸ³æ ‡æ‹ŸéŸ³å¯¹ç…§è¡¨"}</h3><button onClick={onClose} className="p-2 text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 hover:bg-gray-100 dark:hover:bg-slate-700 rounded-full transition"><Icons.X size={20} /></button></div><div className="flex-1 overflow-y-auto p-4 md:p-6 bg-slate-50/50 dark:bg-slate-900/50"><div className="grid grid-cols-1 md:grid-cols-2 gap-6 h-full"><CategorySection title={PHONETIC_DATA.vowels.title} groups={PHONETIC_DATA.vowels.groups} color={PHONETIC_DATA.vowels.color} bg={PHONETIC_DATA.vowels.bg} /><CategorySection title={PHONETIC_DATA.consonants.title} groups={PHONETIC_DATA.consonants.groups} color={PHONETIC_DATA.consonants.color} bg={PHONETIC_DATA.consonants.bg} /></div></div></div></div> );
        };

        const extractPOS = (t) => { if (!t) return {pos:"",cleanTrans:""}; const p=/^([a-z]{1,5}\.(?:[ \t]*[&,/][ \t]*[a-z]{1,5}\.)?)/i; let s=new Set(), l=t.split('\n'); l.forEach(x=>{const m=x.trim().match(p);if(m)s.add(m[1])}); if(s.size===0){const m=t.trim().match(p);if(m)s.add(m[1])} return {pos:Array.from(s).join(' '),cleanTrans:t}; };
        const parseTranslationTags = (t) => { if(!t)return[]; const p=/^([a-z]{1,5}\.(?:[ \t]*[&,/][ \t]*[a-z]{1,5}\.)?)\s*(.*)/i, ts=[]; t.replace(/[\n\rï¼›;ï¼Œ,]/g,'|').split('|').map(s=>s.trim()).filter(s=>s).forEach(x=>{const m=x.match(p);if(m)ts.push(m[1]+" "+m[2]);else ts.push(x)}); return ts; };
        const parseExcelClipboard = (text) => { const rows=[]; let r=[]; let c=""; let q=false; for(let i=0;i<text.length;i++){ const ch=text[i], n=text[i+1]; if(q){ if(ch==='"'){ if(n==='"'){c+='"';i++}else{q=false} }else{c+=ch} }else{ if(ch==='"'){q=true}else if(ch==='\t'){r.push(c.trim());c=""}else if(ch==='\n'||ch==='\r'){if(ch==='\r'&&n==='\n')i++;r.push(c.trim());rows.push(r);r=[];c=""}else{c+=ch} } } if(c||r.length>0){r.push(c.trim());rows.push(r)} return rows; };
        const syllabify = (word) => { if (!word) return ""; if (/[^a-zA-Z]/.test(word)) { return word.split(/(\s+)/).map(part => { return /^[a-zA-Z]+$/.test(part) ? syllabify(part) : part; }).join(''); } const syllableRegex = /[^aeiouy]*[aeiouy]+(?:[^aeiouy]*$|[^aeiouy](?=[^aeiouy]))?/gi; const matches = word.match(syllableRegex); return matches ? matches.join('-') : word; };

        // ==========================================
        // 3. New Component: AI Analysis Card
        // ==========================================
        const AIAnalysisCard = ({ data, word, t }) => {
            if (!data) return null;
            return (
                <div className="space-y-3">
                    {data.analysis && data.analysis.length > 0 && (
                        <div className="space-y-2">
                            {data.analysis.map((item, idx) => (
                                <div key={idx} className="bg-white dark:bg-slate-800/80 p-3 rounded-xl border border-purple-100 dark:border-slate-600 shadow-sm transition hover:shadow-md">
                                    <div className="text-xs italic text-gray-500 dark:text-gray-400 mb-2 leading-relaxed font-serif">"{item.sentence}"</div>
                                    <div className="text-sm font-bold text-gray-800 dark:text-gray-200 mb-2">{item.translation}</div>
                                    <div className="text-xs text-purple-600 dark:text-purple-400 flex items-center bg-purple-50 dark:bg-purple-900/20 px-2 py-1.5 rounded-lg w-fit">
                                        <span className="mr-1.5 text-base">ğŸ’¡</span> 
                                        <span className="font-medium">{item.word_meaning}</span>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}
                    
                    {data.new_example && (
                        <div className="bg-gradient-to-br from-purple-50 to-indigo-50 dark:from-purple-900/20 dark:to-indigo-900/20 p-3 rounded-xl border border-purple-100 dark:border-purple-800/30 shadow-sm">
                            <div className="text-xs font-bold text-purple-600 dark:text-purple-400 mb-2 flex items-center">
                                <Icons.Sparkles size={12} className="mr-1" /> New Example
                            </div>
                            <div className="text-sm text-gray-800 dark:text-gray-200 font-medium mb-1 leading-relaxed" 
                                 dangerouslySetInnerHTML={{ __html: data.new_example.sentence.replace(new RegExp(word, 'gi'), match => `<span class="text-purple-600 dark:text-purple-400 font-bold bg-purple-100 dark:bg-purple-900/50 px-1 rounded">${match}</span>`) }}>
                            </div>
                            <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">{data.new_example.translation}</div>
                        </div>
                    )}
                </div>
            );
        };

        const BrowseView = ({ words, initialIndex, onUpdateWord, setView, onShowPhoneticTable, t, sortMode, setSortMode, syllableMode, onToggleSyllableMode, apiKey, onOpenSettings, showToast }) => {
            const [index, setIndex] = useState(initialIndex);
            const [aiLoading, setAiLoading] = useState(false);
            const [aiResult, setAiResult] = useState(null); // Transient result
            
            const [prevWords, setPrevWords] = useState(words);
            const [currentWordId, setCurrentWordId] = useState(null);

            if (words !== prevWords) {
                setPrevWords(words);
                if (currentWordId) {
                    const newIndex = words.findIndex(w => w.id === currentWordId);
                    setIndex(newIndex !== -1 ? newIndex : 0);
                } else {
                    setIndex(0);
                }
            }

            const safeIndex = (words && words.length > 0) ? (index >= words.length ? 0 : index) : 0;
            const card = (words && words.length > 0) ? words[safeIndex] : null;
            const smartTags = card ? parseTranslationTags(card.translation) : [];
            
            useEffect(() => {
                if (card) {
                    setCurrentWordId(card.id);
                    setAiResult(null); // Reset transient AI result on card change
                }
            }, [safeIndex, words]);

            const touchStartX = useRef(0);
            const touchEndX = useRef(0);
            const minSwipeDistance = 50;
            const onTouchStart = (e) => { touchStartX.current = e.targetTouches[0].clientX; };
            const onTouchMove = (e) => { touchEndX.current = e.targetTouches[0].clientX; };
            const onTouchEnd = () => {
                if (!touchStartX.current || !touchEndX.current) return;
                const distance = touchStartX.current - touchEndX.current;
                if (distance > minSwipeDistance) setIndex((curr) => (curr + 1) % words.length);
                else if (distance < -minSwipeDistance) setIndex((curr) => (curr - 1 + words.length) % words.length);
                touchStartX.current = 0; touchEndX.current = 0;
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (words.length > 0 && document.activeElement.tagName !== 'TEXTAREA' && document.activeElement.tagName !== 'INPUT') {
                        if (e.key === 'ArrowRight') setIndex((curr) => (curr + 1) % words.length);
                        else if (e.key === 'ArrowLeft') setIndex((curr) => (curr - 1 + words.length) % words.length);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [words.length]);

            if (!card) return <div className="h-full flex items-center justify-center text-gray-500 dark:text-gray-400 flex-col"><div className="text-xl mb-2">{t.empty_browse}</div><div className="text-sm">è¯·å°è¯•å¯¼å…¥æ•°æ®</div></div>;

            const speak = () => { if (!card.word) return; const u = new SpeechSynthesisUtterance(card.word); u.lang = 'en-US'; window.speechSynthesis.speak(u); };
            const updateKeyMeaning = (val) => { onUpdateWord(card.id, { keyMeaning: val }); };

            const handleAiAnalyze = async () => {
                if (!apiKey) {
                    showToast(t.ai_no_key, 'error');
                    onOpenSettings();
                    return;
                }
                setAiLoading(true);
                try {
                    const result = await callDeepSeek(apiKey, card.word, card.note);
                    setAiResult(result);
                } catch (e) {
                    showToast(e.message, 'error');
                } finally {
                    setAiLoading(false);
                }
            };

            const handleSaveAI = () => {
                if (aiResult) {
                    onUpdateWord(card.id, { aiAnalysis: aiResult });
                    setAiResult(null); // Clear transient result to show saved one
                    showToast(t.ai_saved, 'success');
                }
            };

            return (
                <div className="h-full flex items-center justify-center relative px-2 sm:px-4" onTouchStart={onTouchStart} onTouchMove={onTouchMove} onTouchEnd={onTouchEnd}>
                    <button onClick={() => setIndex((curr) => (curr - 1 + words.length) % words.length)} className="hidden md:block absolute left-0 top-1/2 -translate-y-1/2 p-4 text-gray-400 hover:text-indigo-600 hover:bg-indigo-50 dark:hover:bg-slate-700 rounded-full transition z-20"><Icons.ArrowRight className="rotate-180" size={32}/></button>
                    <button onClick={() => setIndex((curr) => (curr + 1) % words.length)} className="hidden md:block absolute right-0 top-1/2 -translate-y-1/2 p-4 text-gray-400 hover:text-indigo-600 hover:bg-indigo-50 dark:hover:bg-slate-700 rounded-full transition z-20"><Icons.ArrowRight size={32}/></button>
                    
                    <div className="w-full max-w-2xl glass-card rounded-3xl p-6 md:p-12 relative flex flex-col justify-between min-h-[500px] md:min-h-[600px] shadow-xl">
                        {/* Header Controls */}
                        <div className="flex justify-between items-start mb-4 md:mb-6">
                            <div className="flex items-center space-x-2">
                                <div className="text-xs md:text-sm font-mono text-gray-400 bg-gray-100 dark:bg-slate-700 px-2 md:px-3 py-1 rounded-full">{safeIndex + 1} / {words.length}</div>
                                <SortMenu sortMode={sortMode} setSortMode={setSortMode} t={t} />
                            </div>
                            <div className="flex space-x-1 md:space-x-2">
                                <button onClick={() => onUpdateWord(card.id, { isFavorite: !card.isFavorite })} className={`p-2 rounded-full transition active:scale-90 ${card.isFavorite ? 'text-yellow-400' : 'text-gray-300 dark:text-gray-500 hover:bg-gray-100 dark:hover:bg-slate-700'}`}><Icons.Star fill={card.isFavorite ? "currentColor" : "none"} /></button>
                                <button onClick={speak} className="p-2 rounded-full text-indigo-500 hover:bg-indigo-50 dark:hover:bg-slate-700 active:scale-90 transition"><Icons.Volume2 /></button>
                                <button onClick={() => { onUpdateWord(card.id, { archived: true }); }} className="p-2 rounded-full text-gray-400 hover:text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 active:scale-90 transition"><Icons.Archive /></button>
                            </div>
                        </div>
                        
                        {/* Main Word */}
                        <div className="text-center mb-4 md:mb-6 flex-shrink-0">
                            <h2 className="text-4xl md:text-6xl font-black text-gray-800 dark:text-gray-100 mb-2 tracking-tight break-words">
                                {syllableMode ? syllabify(card.word) : card.word}
                            </h2>
                            <div className="flex items-center justify-center space-x-2 mb-2 h-6">
                                <div className="text-base md:text-xl text-gray-400 font-phonetic">{card.phonetic || <span className="text-xs bg-gray-100 dark:bg-slate-700 px-2 py-1 rounded font-sans">{t.no_phonetic}</span>}</div>
                                <button onClick={onShowPhoneticTable} className="text-indigo-400 hover:text-indigo-600 transition" title={t.phonetic_help}><Icons.HelpCircle size={16} /></button>
                            </div>
                        </div>
                        
                        {/* Key Meaning */}
                        <div className="bg-white/60 dark:bg-slate-800/60 rounded-xl p-3 md:p-4 border border-indigo-100 dark:border-slate-600 shadow-sm mb-3 md:mb-4 flex-shrink-0">
                            <div className="flex items-center justify-between mb-2"><div className="text-xs font-bold text-indigo-600 dark:text-indigo-400 uppercase flex items-center"><Icons.PenTool size={12} className="mr-1"/> {t.key_meaning}</div></div>
                            <textarea className="w-full bg-transparent border-b border-dashed border-gray-300 dark:border-slate-500 focus:border-indigo-500 focus:outline-none text-base md:text-lg font-bold text-gray-800 dark:text-gray-100 placeholder-gray-300 py-1" rows="1" placeholder={t.key_meaning_ph} value={card.keyMeaning || ""} onChange={(e) => updateKeyMeaning(e.target.value)}></textarea>
                            <div className="mt-2 md:mt-3 flex flex-wrap gap-2">
                                <span className="text-xs text-gray-400 mr-1 self-center">{t.quick_pick}</span>
                                {smartTags.map((tag, idx) => {
                                    const parts = (card.keyMeaning || "").split(/[,;ï¼Œï¼›]/).map(s => s.trim());
                                    const isActive = parts.includes(tag);
                                    return <button key={idx} onClick={() => {
                                        let newParts = isActive ? parts.filter(p => p !== tag) : [...parts.filter(Boolean), tag];
                                        updateKeyMeaning(newParts.join("ï¼›"));
                                    }} className={`text-[10px] md:text-xs px-2 py-1 rounded border transition active:scale-95 flex items-center ${isActive ? 'bg-indigo-600 border-indigo-600 text-white' : 'bg-white dark:bg-slate-700 border-indigo-100 dark:border-slate-600 text-indigo-600 dark:text-indigo-400 hover:bg-indigo-50 dark:hover:bg-slate-600'}`}>{tag} {isActive && "Ã—"}</button>;
                                })}
                            </div>
                        </div>
                        
                        <div className="w-full h-px bg-gray-100 dark:bg-slate-700 mb-3 md:mb-4"></div>
                        
                        {/* Scrollable Content */}
                        <div className="flex-1 overflow-y-auto max-h-48 md:max-h-full scrollbar-hide relative pb-10">
                            <div className="mb-4">
                                <h3 className="text-base md:text-lg text-gray-500 dark:text-gray-300 font-medium px-1 whitespace-pre-wrap leading-relaxed">{card.translation}</h3>
                            </div>
                            
                            {/* User Note Section */}
                            <div className="bg-indigo-50/50 dark:bg-indigo-900/30 rounded-xl p-3 border border-indigo-100/50 dark:border-indigo-800/30 relative group mb-4">
                                <div className="flex justify-between items-center mb-1">
                                    <div className="text-xs font-bold text-indigo-400 uppercase flex items-center"><Icons.FileText size={12} className="mr-1"/> {t.note}</div>
                                </div>
                                <div className="text-gray-700 dark:text-gray-300 text-xs md:text-sm leading-relaxed whitespace-pre-wrap" dangerouslySetInnerHTML={{__html: card.note}}></div>
                                {card.source && <div className="flex items-center justify-end text-xs text-gray-400 mt-1"><Icons.Link size={10} className="mr-1"/> <span className="truncate max-w-xs">{card.source}</span></div>}
                            </div>

                            {/* AI Analysis Section */}
                            <div className="relative">
                                <div className="flex justify-between items-center mb-2">
                                    <span className="text-xs font-bold text-purple-600 dark:text-purple-400 uppercase flex items-center">
                                        <Icons.Sparkles size={12} className="mr-1"/> {t.ai_analysis_title}
                                    </span>
                                    <button onClick={handleAiAnalyze} disabled={aiLoading} className="text-xs bg-white dark:bg-slate-700 border border-indigo-200 dark:border-slate-500 text-indigo-600 dark:text-indigo-300 px-2 py-1 rounded-full flex items-center shadow-sm hover:bg-indigo-50 dark:hover:bg-slate-600 transition disabled:opacity-50">
                                        {aiLoading ? <span className="animate-spin mr-1">â³</span> : <Icons.Wand2 size={12} className="mr-1"/>}
                                        {aiLoading ? t.ai_analyzing : (card.aiAnalysis || aiResult ? "Re-Analyze" : t.ai_analyze)}
                                    </button>
                                </div>
                                
                                {/* Transient AI Result (Preview) */}
                                {aiResult && (
                                    <div className="bg-purple-50/80 dark:bg-slate-800 rounded-xl p-3 border-2 border-purple-200 dark:border-purple-800 mb-4 animate-slide-down">
                                        <div className="flex justify-between items-center mb-3 pb-2 border-b border-purple-100 dark:border-slate-700">
                                            <span className="text-xs font-bold text-purple-600 dark:text-purple-400">âš¡ Preview</span>
                                            <button onClick={handleSaveAI} className="text-xs bg-purple-600 text-white px-3 py-1 rounded-lg font-bold shadow hover:bg-purple-700 transition flex items-center">
                                                <Icons.Check size={12} className="mr-1" /> {t.ai_save}
                                            </button>
                                        </div>
                                        <AIAnalysisCard data={aiResult} word={card.word} t={t} />
                                    </div>
                                )}

                                {/* Saved AI Analysis */}
                                {card.aiAnalysis && !aiResult && (
                                    <div className="animate-slide-down">
                                        <AIAnalysisCard data={card.aiAnalysis} word={card.word} t={t} />
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>

                    <div className="absolute bottom-6 right-6 md:right-12 z-20">
                         <button 
                            onClick={onToggleSyllableMode}
                            className={`p-3 rounded-full shadow-lg transition-all active:scale-90 flex items-center justify-center border dark:border-slate-600 ${syllableMode ? 'bg-indigo-600 text-white border-indigo-600' : 'bg-white dark:bg-slate-700 text-gray-400 dark:text-gray-400'}`}
                            title={t.syllable_mode}
                        >
                            <Icons.Split size={20} />
                        </button>
                    </div>
                </div>
            );
        };

        const SpellingView = ({ words, onUpdateWord, t }) => { const [step, setStep] = useState('setup'); const [queue, setQueue] = useState([]); const [idx, setIdx] = useState(0); const [input, setInput] = useState(''); const [feedback, setFeedback] = useState('idle'); const [stats, setStats] = useState({ correct: 0, wrong: 0 }); const [config, setConfig] = useState({ mode: 'random', count: 5, hint: 'copy', errorMode: 'retry', scope: 'all' }); const [showHintTemp, setShowHintTemp] = useState(false); const inputRef = useRef(null); useEffect(() => { if (step === 'game' && inputRef.current) inputRef.current.focus(); }, [step, idx, feedback]); const start = () => { let q = [...words]; if (config.scope === 'favorites') q = q.filter(w => w.isFavorite); if (config.scope === 'unmastered') q = q.filter(w => !w.mastered); if (config.mode === 'random') q = q.sort(() => Math.random() - 0.5); if (config.count !== 'all') q = q.slice(0, parseInt(config.count)); if (q.length === 0) { alert(t.empty_spelling); return; } setQueue(q); setIdx(0); setInput(''); setFeedback('idle'); setStats({ correct: 0, wrong: 0 }); setStep('game'); }; const speak = (text) => { const u = new SpeechSynthesisUtterance(text); u.lang = 'en-US'; window.speechSynthesis.speak(u); }; const check = () => { const card = queue[idx]; if (input.trim().toLowerCase() === card.word.trim().toLowerCase()) { setFeedback('correct'); speak(card.word); setStats(s => ({ ...s, correct: s.correct + 1 })); onUpdateWord(card.id, { stats: { correct: (card.stats?.correct||0)+1, wrong: card.stats?.wrong||0 } }); } else { setFeedback('wrong'); setStats(s => ({ ...s, wrong: s.wrong + 1 })); onUpdateWord(card.id, { stats: { correct: card.stats?.correct||0, wrong: (card.stats?.wrong||0)+1 } }); } }; const next = () => { if (idx < queue.length - 1) { setIdx(i => i + 1); setInput(''); setFeedback('idle'); } else setStep('result'); }; const handleKey = (e) => { if (e.key === 'Enter') { e.preventDefault(); if (feedback === 'idle') check(); else if (feedback === 'correct') next(); else if (feedback === 'wrong') { config.errorMode === 'retry' ? (setInput(''), setFeedback('idle')) : next(); } } }; const OptionGroup = ({ title, children }) => ( <div className="mb-4"> <div className="text-xs font-bold text-gray-400 dark:text-gray-500 uppercase mb-2 tracking-wider">{title}</div> <div className="grid grid-cols-2 gap-2">{children}</div> </div> ); const OptionCard = ({ active, onClick, title, desc, icon }) => ( <button onClick={onClick} className={`p-3 rounded-xl border-2 text-left transition-all ${active ? 'border-indigo-600 bg-indigo-50 dark:bg-indigo-900/30 dark:border-indigo-400' : 'border-gray-100 dark:border-slate-700 bg-white dark:bg-slate-800 hover:border-indigo-200 dark:hover:border-slate-600'}`}> <div className={`text-sm font-bold mb-1 ${active ? 'text-indigo-700 dark:text-indigo-300' : 'text-gray-700 dark:text-gray-300'}`}>{title}</div> {desc && <div className="text-[10px] text-gray-400">{desc}</div>} </button> ); if (step === 'setup') return ( <div className="max-w-xl mx-auto p-6 md:p-8 glass-card rounded-3xl"> <h2 className="text-2xl font-black text-gray-800 dark:text-gray-100 mb-6 flex items-center"><Icons.Edit3 className="mr-2 text-indigo-500" size={24} /> {t.spelling_setup}</h2> <OptionGroup title={t.spelling_mode}> <OptionCard active={config.mode === 'random'} onClick={() => setConfig({...config, mode: 'random'})} title={t.mode_random} desc="Random order" /> <OptionCard active={config.mode === 'seq'} onClick={() => setConfig({...config, mode: 'seq'})} title={t.mode_seq} desc="Sequential order" /> </OptionGroup> <OptionGroup title={t.spelling_hint}> <OptionCard active={config.hint === 'copy'} onClick={() => setConfig({...config, hint: 'copy'})} title={t.hint_copy} desc="Show word" /> <OptionCard active={config.hint === 'blind'} onClick={() => setConfig({...config, hint: 'blind'})} title={t.hint_blind} desc="Hide word" /> </OptionGroup> <OptionGroup title={t.spelling_count}> <OptionCard active={config.count === 5} onClick={() => setConfig({...config, count: 5})} title="5 Words" /> <OptionCard active={config.count === 'all'} onClick={() => setConfig({...config, count: 'all'})} title={t.count_all} /> </OptionGroup> <button onClick={start} className="w-full mt-4 py-4 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-700 hover:to-purple-700 text-white font-bold rounded-xl shadow-lg transform active:scale-95 transition-all text-lg flex items-center justify-center"> <Icons.Game className="mr-2" /> {t.start} </button> </div> ); if (step === 'result') return ( <div className="max-w-md mx-auto p-8 text-center glass-card rounded-3xl animate-pop"> <h2 className="text-3xl font-black text-gray-800 dark:text-gray-100 mb-8">{t.result}</h2> <div className="grid grid-cols-2 gap-6 mb-8"> <div className="bg-green-100 dark:bg-green-900/30 p-6 rounded-2xl border border-green-200 dark:border-green-800"><div className="text-4xl text-green-600 font-black mb-1">{stats.correct}</div><div className="text-xs font-bold text-green-600 uppercase tracking-widest">{t.correct}</div></div> <div className="bg-red-100 dark:bg-red-900/30 p-6 rounded-2xl border border-red-200 dark:border-red-800"><div className="text-4xl text-red-500 font-black mb-1">{stats.wrong}</div><div className="text-xs font-bold text-red-500 uppercase tracking-widest">{t.wrong}</div></div> </div> <button onClick={() => setStep('setup')} className="w-full py-3 bg-gray-100 dark:bg-slate-700 font-bold rounded-xl text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-slate-600">{t.back_setup}</button> </div> ); const card = queue[idx]; const isCorrect = feedback === 'correct'; const isWrong = feedback === 'wrong'; return ( <div className="max-w-xl mx-auto p-6 md:p-10 glass-card rounded-3xl relative overflow-hidden flex flex-col min-h-[500px]"> <div className="absolute top-0 left-0 h-1.5 bg-gray-100 dark:bg-slate-700 w-full"><div className="h-full bg-indigo-500 transition-all duration-300" style={{width: `${(idx/queue.length)*100}%`}}></div></div> <div className="flex-1 flex flex-col items-center justify-center mb-8 text-center"> <div className="text-gray-400 text-xs uppercase tracking-widest font-bold mb-6">{t.translate_this}</div> <h3 className="text-3xl md:text-4xl text-gray-800 dark:text-gray-100 font-black leading-tight flex flex-col items-center mb-8"> {card.keyMeaning ? <span className="text-indigo-900 dark:text-indigo-300">{card.keyMeaning}</span> : card.translation.split('\n')[0]} </h3> <div className={`transition-all duration-300 overflow-hidden ${config.hint === 'copy' || isCorrect || isWrong || showHintTemp ? 'opacity-100 scale-100' : 'opacity-0 scale-95 blur-sm'}`}> <div className={`text-5xl font-black tracking-wider font-mono mt-2 ${isCorrect ? 'text-green-500' : isWrong ? 'text-red-500' : 'text-indigo-600 dark:text-indigo-400'}`}>{card.word}</div> </div> </div> <div className="relative w-full"> <input ref={inputRef} type="text" value={input} onChange={(e) => setInput(e.target.value)} onKeyDown={handleKey} readOnly={isCorrect} className={`w-full bg-white dark:bg-slate-800 border-2 text-center text-3xl font-bold py-5 rounded-2xl focus:outline-none transition-all shadow-sm ${isCorrect ? 'border-green-500 text-green-600 bg-green-50 dark:bg-green-900/20 ring-4 ring-green-100 dark:ring-green-900/30' : isWrong ? 'border-red-500 text-red-500 bg-red-50 dark:bg-red-900/20 animate-shake' : 'border-gray-200 dark:border-slate-600 text-gray-800 dark:text-gray-100 focus:border-indigo-500 focus:ring-4 focus:ring-indigo-100 dark:focus:ring-indigo-900/30'}`} autoComplete="off" spellCheck="false" placeholder={t.type_ph} /> {config.hint === 'blind' && !isCorrect && !isWrong && ( <button onMouseDown={() => setShowHintTemp(true)} onMouseUp={() => setShowHintTemp(false)} onTouchStart={() => setShowHintTemp(true)} onTouchEnd={() => setShowHintTemp(false)} className="absolute right-4 top-1/2 -translate-y-1/2 text-gray-300 hover:text-indigo-500 p-2" title={t.peek} > <Icons.Eye size={20} /> </button> )} </div> <div className="text-center mt-6 h-8 text-sm font-bold text-gray-400 dark:text-gray-500"> {isCorrect ? <span className="text-green-600 dark:text-green-400 animate-pulse">{t.press_enter_next}</span> : isWrong ? <span className="text-red-500">{t.try_again}</span> : t.press_enter_check} </div> </div> ); };
        const ListView = ({ words, onUpdateWord, onDeleteWord, onClearAll, onFetchPhonetics, onExport, onJump, t }) => { const [tab, setTab] = useState('active'); const activeCount = words.filter(w => !w.archived).length; const archivedCount = words.filter(w => w.archived).length; const displayWords = words.filter(w => tab === 'active' ? !w.archived : w.archived).sort((a,b) => (b.isFavorite?1:0) - (a.isFavorite?1:0)); return ( <div className="glass-card rounded-3xl overflow-hidden flex flex-col max-h-[80vh]"> <div className="p-3 md:p-4 border-b border-gray-200/50 dark:border-slate-700/50 bg-white/40 dark:bg-slate-800/40 flex justify-between items-center"> <div className="flex space-x-4"> <button onClick={() => setTab('active')} className={`text-sm font-bold pb-2 border-b-2 transition-colors ${tab === 'active' ? 'text-indigo-600 dark:text-indigo-400 border-indigo-600 dark:border-indigo-400' : 'text-gray-400 border-transparent'}`}> {t.active} <span className="ml-1 text-xs bg-indigo-100 dark:bg-indigo-900/50 text-indigo-600 dark:text-indigo-300 px-1.5 py-0.5 rounded-full">{activeCount}</span> </button> <button onClick={() => setTab('archived')} className={`text-sm font-bold pb-2 border-b-2 transition-colors ${tab === 'archived' ? 'text-indigo-600 dark:text-indigo-400 border-indigo-600 dark:border-indigo-400' : 'text-gray-400 border-transparent'}`}> {t.archived} <span className="ml-1 text-xs bg-gray-100 dark:bg-slate-700 text-gray-500 dark:text-gray-400 px-1.5 py-0.5 rounded-full">{archivedCount}</span> </button> </div> <div className="flex items-center space-x-1"> <button onClick={onExport} className="text-xs flex items-center px-2 py-1 bg-green-50 text-green-600 rounded border border-green-100 dark:bg-green-900/30 dark:text-green-400 dark:border-transparent"><Icons.Download size={12}/></button> <button onClick={onFetchPhonetics} className="text-xs flex items-center px-2 py-1 bg-indigo-50 text-indigo-600 rounded dark:bg-indigo-900/30 dark:text-indigo-400"><Icons.Wand2 size={12}/></button> <button onClick={onClearAll} className="text-xs text-red-400 hover:text-red-600 p-1"><Icons.Trash2 size={12}/></button> </div> </div> <div className="overflow-y-auto flex-1"> <table className="w-full text-left text-sm"> <tbody className="divide-y divide-gray-100/50 dark:divide-slate-700/50"> {displayWords.map(w => ( <tr key={w.id} onClick={(e) => { if(!e.target.closest('button')) onJump(w.id); }} className="hover:bg-indigo-50/30 dark:hover:bg-indigo-500/10 cursor-pointer transition active:bg-indigo-100 dark:active:bg-slate-700"> <td className="p-3 md:p-4 w-1/3"> <div className="font-bold flex items-center text-gray-800 dark:text-gray-200 text-sm md:text-base">{w.isFavorite && <span className="text-yellow-400 mr-1">â˜…</span>}{w.word}</div> <div className="flex items-center mt-1 text-xs text-gray-400 font-phonetic">{w.phonetic}</div> </td> <td className="p-3 md:p-4 text-gray-600 dark:text-gray-400 max-w-xs truncate text-xs md:text-sm"> {w.keyMeaning ? <span className="text-indigo-600 dark:text-indigo-400 font-bold mr-1 bg-indigo-50 dark:bg-indigo-900/30 px-1 rounded">{w.keyMeaning}</span> : w.translation} </td> <td className="p-3 md:p-4 text-right space-x-2 w-20"> <button onClick={() => onDeleteWord(w.id)} className="text-gray-300 hover:text-red-500 p-1"><Icons.Trash2 size={16}/></button> </td> </tr> ))} </tbody> </table> </div> </div> ); };
        
        const ImportView = ({ onImport, t, existingWords }) => { 
            const [text, setText] = useState(''); 
            const [previewWords, setPreviewWords] = useState([]); 
            const [excludeExisting, setExcludeExisting] = useState(true);

            const handleFile = (e) => { const file = e.target.files[0]; if (!file) return; e.target.value = ''; const reader = new FileReader(); reader.onload = (evt) => setText(evt.target.result); reader.readAsText(file); }; 
            
            const handleAnalyze = () => { 
                if (!text.trim()) return; 
                let newWords = []; 
                if (text.includes('å•è¯ï¼š')) { 
                    const blocks = text.split(/(?=å•è¯ï¼š)/).filter(b => b.trim().length > 0); 
                    newWords = blocks.map((block, i) => { const getVal = (key) => { const r = new RegExp(`${key}ï¼š([\\s\\S]*?)(?=\\n(?:å•è¯|é‡Šä¹‰|éŸ³æ ‡|ç¬”è®°|æ¥æº|åŠ©è®°|æ•°æ®|è¯æ€§)ï¼š|$)`); const m = block.match(r); return m ? m[1].trim() : ""; }; const w = getVal('å•è¯'); if (!w) return null; const { pos, cleanTrans } = extractPOS(getVal('é‡Šä¹‰')); let meta = { mastered: false, isFavorite: false, archived: false, stats: { correct: 0, wrong: 0 } }; const dj = getVal('æ•°æ®'); if (dj) { try { meta = { ...meta, ...JSON.parse(dj) }; } catch(e) {} } return { id: Date.now()+i, word: w, translation: cleanTrans||"No def", phonetic: getVal('éŸ³æ ‡'), pos, note: getVal('ç¬”è®°'), source: getVal('æ¥æº'), keyMeaning: getVal('åŠ©è®°'), ...meta }; }).filter(Boolean); 
                } else { 
                    newWords = parseExcelClipboard(text).map((c, i) => { if (c.length < 2) return null; const { pos, cleanTrans } = extractPOS(c[1] || ""); return { id: Date.now()+i, word: c[0], translation: cleanTrans, phonetic: c[2]||"", pos, mastered: c[3]?.toLowerCase()==='yes', note: c[4]||"", source: "Excel", keyMeaning: "", isFavorite: false, archived: false, stats: { correct: 0, wrong: 0 } }; }).filter(Boolean); 
                } 
                setPreviewWords(newWords); 
            }; 
            
            const handleConfirm = () => { 
                let wordsToImport = previewWords;
                if (excludeExisting && existingWords) {
                    const existingSet = new Set(existingWords.map(w => w.word.toLowerCase().trim()));
                    wordsToImport = previewWords.filter(w => !existingSet.has(w.word.toLowerCase().trim()));
                }
                
                onImport(wordsToImport); 
                setPreviewWords([]); 
                setText(''); 
            }; 

            return ( 
                <div className="p-6 md:p-8 max-w-2xl mx-auto glass-card rounded-3xl h-full flex flex-col"> 
                    <h3 className="text-lg font-bold text-gray-800 dark:text-gray-100 mb-4 flex items-center"><Icons.Upload className="mr-2 text-indigo-500" /> {t.import_title}</h3> 
                    {previewWords.length === 0 ? ( 
                        <div className="space-y-4 flex-1 flex flex-col"> 
                            <div className="border-2 border-dashed border-indigo-200 dark:border-slate-600 bg-indigo-50/30 dark:bg-slate-700/30 rounded-2xl p-6 text-center relative active:bg-indigo-100 dark:active:bg-slate-700 transition cursor-pointer group"> 
                                <input type="file" accept=".csv,.txt" onChange={handleFile} className="absolute inset-0 w-full h-full opacity-0 cursor-pointer" /> 
                                <div className="w-12 h-12 bg-indigo-100 dark:bg-indigo-900/50 text-indigo-500 dark:text-indigo-400 rounded-full flex items-center justify-center mx-auto mb-2"><Icons.FileText size={24} /></div> 
                                <p className="text-sm font-bold text-indigo-900 dark:text-indigo-300 mb-1">{t.import_click}</p> 
                                <p className="text-xs text-gray-400">{t.import_desc}</p> 
                            </div> 
                            <textarea value={text} onChange={e => setText(e.target.value)} className="w-full flex-1 p-3 border rounded-xl bg-white/50 dark:bg-slate-800/50 text-xs text-gray-800 dark:text-gray-200 border-gray-200 dark:border-slate-600 focus:outline-none focus:border-indigo-500 font-mono" placeholder={t.import_ph}></textarea> 
                            <button onClick={handleAnalyze} disabled={!text.trim()} className="w-full py-3 bg-indigo-600 disabled:bg-gray-300 dark:disabled:bg-slate-700 text-white rounded-xl font-bold shadow-lg transition-colors">{t.import_check}</button> 
                        </div> 
                    ) : ( 
                        <div className="flex-1 flex flex-col items-center justify-center space-y-6"> 
                            <div className="w-20 h-20 bg-green-100 dark:bg-green-900/30 text-green-500 rounded-full flex items-center justify-center animate-pop"> 
                                <Icons.Check size={40} /> 
                            </div> 
                            <div className="text-center"> 
                                <h4 className="text-xl font-bold text-gray-800 dark:text-gray-100 mb-2">Found {previewWords.length} Words</h4> 
                                <p className="text-sm text-gray-500 dark:text-gray-400">Ready to add to your library.</p> 
                            </div>
                            
                            <div className="flex items-center justify-center mb-2">
                                <label className="flex items-center space-x-2 cursor-pointer bg-gray-50 dark:bg-slate-700/50 px-4 py-2 rounded-xl">
                                    <input type="checkbox" checked={excludeExisting} onChange={e => setExcludeExisting(e.target.checked)} className="accent-indigo-600 w-4 h-4" />
                                    <span className="text-sm font-medium text-gray-700 dark:text-gray-300">{t.import_exclude}</span>
                                </label>
                            </div>

                            <div className="flex w-full space-x-3"> 
                                <button onClick={() => setPreviewWords([])} className="flex-1 py-3 bg-gray-100 dark:bg-slate-700 text-gray-600 dark:text-gray-300 rounded-xl font-bold">Cancel</button> 
                                <button onClick={handleConfirm} className="flex-1 py-3 bg-green-500 hover:bg-green-600 text-white rounded-xl font-bold shadow-lg">Confirm</button> 
                            </div> 
                        </div> 
                    )} 
                </div> 
            ); 
        };

        function WordReviewApp() {
            const [words, setWords] = useState(() => { try { return JSON.parse(localStorage.getItem('my_vocab_data_v4_pro')) || DEMO_DATA; } catch (e) { return DEMO_DATA; } });
            const [view, setView] = useState('browse');
            const [browseId, setBrowseId] = useState(null);
            const [lang, setLang] = useState('zh');
            const [showPhoneticTable, setShowPhoneticTable] = useState(false);
            const [showSettings, setShowSettings] = useState(false);
            const [sortMode, setSortMode] = useState('default'); 
            const [randomSeed, setRandomSeed] = useState(0);
            const [toast, setToast] = useState(null);
            
            const [theme, setTheme] = useState(() => localStorage.getItem('theme') || 'light');
            const [syllableMode, setSyllableMode] = useState(() => localStorage.getItem('syllableMode') === 'true');
            const [apiKey, setApiKey] = useState(() => localStorage.getItem('deepseek_api_key') || '');

            const t = I18N[lang];

            useEffect(() => localStorage.setItem('my_vocab_data_v4_pro', JSON.stringify(words)), [words]);
            
            useEffect(() => {
                if (theme === 'dark') {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
                localStorage.setItem('theme', theme);
            }, [theme]);

            useEffect(() => {
                localStorage.setItem('syllableMode', syllableMode);
            }, [syllableMode]);

            useEffect(() => {
                localStorage.setItem('deepseek_api_key', apiKey);
            }, [apiKey]);

            const showToast = (msg, type='info') => {
                setToast({ msg, type });
            };

            const updateWord = (id, changes) => setWords(prev => prev.map(w => w.id === id ? { ...w, ...changes } : w));
            const deleteWord = (id) => setWords(prev => prev.filter(w => w.id !== id));
            
            const handleImportData = (newWords) => {
                if (newWords.length > 0) { 
                    setWords(prev => [...prev, ...newWords]); 
                    setView('list'); 
                    showToast(t.import_success(newWords.length), 'success');
                } else { 
                    showToast("No new words imported", 'info');
                }
            };

            const handleExport = () => {
                if (words.length === 0) { showToast("No data to export", 'error'); return; }
                const txt = words.map(w => `å•è¯ï¼š${w.word}\né‡Šä¹‰ï¼š${w.translation}\néŸ³æ ‡ï¼š${w.phonetic}\nç¬”è®°ï¼š${w.note}\næ¥æºï¼š${w.source}\nåŠ©è®°ï¼š${w.keyMeaning}\næ•°æ®ï¼š${JSON.stringify({mastered:w.mastered,isFavorite:w.isFavorite,archived:w.archived,stats:w.stats, aiAnalysis: w.aiAnalysis})}\n`).join('\n');
                const blob = new Blob([txt], { type: "text/plain;charset=utf-8" });
                const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = "backup.txt"; document.body.appendChild(a); a.click(); document.body.removeChild(a);
            };
            
            const fetchPhonetics = async () => { 
                showToast("Fetching phonetics...", 'info');
                let c=0; let nws=[...words]; 
                for(let i=0;i<nws.length;i++){ 
                    if(!nws[i].phonetic){ 
                        try{ 
                            const r=await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${nws[i].word}`); 
                            if(r.ok){ const d=await r.json(); const p=d[0]?.phonetic||d[0]?.phonetics?.find(x=>x.text)?.text; if(p){nws[i].phonetic=p;c++} } 
                        }catch(e){} 
                        await new Promise(r=>setTimeout(r,50)); 
                    } 
                } 
                setWords(nws); 
                showToast(`Fetched ${c} phonetics`, 'success');
            };

            const activeWords = useMemo(() => {
                let filtered = words.filter(w => !w.archived);
                const shuffle = (array, seed) => {
                    let m = array.length, t, i;
                    const seededRandom = (s) => {
                        var x = Math.sin(s++) * 10000;
                        return x - Math.floor(x);
                    };
                    let map = array.map((item, idx) => ({ item, r: seededRandom(seed + idx) }));
                    map.sort((a, b) => a.r - b.r);
                    return map.map(x => x.item);
                };

                switch (sortMode) {
                    case 'az': return [...filtered].sort((a, b) => a.word.localeCompare(b.word));
                    case 'za': return [...filtered].sort((a, b) => b.word.localeCompare(a.word));
                    case 'random': return shuffle([...filtered], randomSeed);
                    default: return filtered;
                }
            }, [words, sortMode, randomSeed]);

            const handleSetSortMode = (mode) => {
                if (mode === 'random' && sortMode === 'random') {
                    setRandomSeed(s => s + 1);
                } else if (mode === 'random') {
                    setRandomSeed(Date.now());
                }
                setSortMode(mode);
            };

            const initialIndex = browseId ? activeWords.findIndex(w => w.id === browseId) : 0;
            const safeIndex = initialIndex >= 0 ? initialIndex : 0;

            return (
                <div className="bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-slate-900 dark:to-slate-800 flex flex-col min-h-screen relative transition-colors duration-300">
                    <div className="fixed top-0 left-0 w-full h-full overflow-hidden pointer-events-none -z-10"><div className="absolute top-0 left-1/4 w-96 h-96 bg-purple-300 dark:bg-purple-900/30 rounded-full mix-blend-multiply dark:mix-blend-screen filter blur-3xl opacity-30 animate-blob"></div><div className="absolute top-0 right-1/4 w-96 h-96 bg-yellow-300 dark:bg-indigo-900/30 rounded-full mix-blend-multiply dark:mix-blend-screen filter blur-3xl opacity-30 animate-blob animation-delay-2000"></div></div>
                    
                    <header className="px-4 py-3 z-20 sticky top-0">
                        <div className="glass-card rounded-2xl p-2 flex items-center justify-between shadow-sm">
                            <div className="flex space-x-1 overflow-x-auto scrollbar-hide flex-1 mr-2">
                                {[{ id: 'browse', iconName: 'Eye', label: t.browse }, { id: 'spelling', iconName: 'Edit3', label: t.spelling }, { id: 'list', iconName: 'List', label: t.list }, { id: 'import', iconName: 'Upload', label: t.import }].map(tab => (
                                    <GlassButton key={tab.id} active={view === tab.id} onClick={() => setView(tab.id)} iconName={tab.iconName} label={tab.label} />
                                ))}
                                <GlassButton onClick={() => setShowPhoneticTable(true)} iconName="Wand2" label={t.phonetic_table} className="text-indigo-600 dark:text-indigo-400" />
                            </div>
                            
                            <div className="flex items-center space-x-2">
                                <button onClick={() => setShowSettings(true)} className="glass-card p-2 rounded-full hover:bg-white/80 dark:hover:bg-slate-700 transition text-gray-500 dark:text-gray-400 flex items-center flex-shrink-0 shadow-sm" title="API Settings"><Icons.Settings size={18} /></button>
                                <button onClick={() => setTheme(t => t === 'light' ? 'dark' : 'light')} className="glass-card p-2 rounded-full hover:bg-white/80 dark:hover:bg-slate-700 transition text-yellow-500 dark:text-yellow-400 flex items-center flex-shrink-0 shadow-sm">{theme === 'light' ? <Icons.Sun size={18} /> : <Icons.Moon size={18} />}</button>
                                <button onClick={() => setLang(l => l === 'zh' ? 'en' : 'zh')} className="glass-card p-2 rounded-full hover:bg-white/80 dark:hover:bg-slate-700 transition text-indigo-600 dark:text-indigo-400 font-bold flex items-center flex-shrink-0 shadow-sm"><Icons.Globe size={18} className="mr-1" /> {lang.toUpperCase()}</button>
                            </div>
                        </div>
                    </header>

                    <main className="flex-1 max-w-5xl mx-auto w-full p-4 flex flex-col relative z-0">
                        {view === 'browse' && <BrowseView words={activeWords} initialIndex={safeIndex} onUpdateWord={updateWord} setView={setView} onShowPhoneticTable={() => setShowPhoneticTable(true)} t={t} sortMode={sortMode} setSortMode={handleSetSortMode} syllableMode={syllableMode} onToggleSyllableMode={() => setSyllableMode(!syllableMode)} apiKey={apiKey} onOpenSettings={() => setShowSettings(true)} showToast={showToast} />}
                        {view === 'spelling' && <SpellingView words={activeWords} onUpdateWord={updateWord} t={t} />}
                        {view === 'list' && <ListView words={words} onUpdateWord={updateWord} onDeleteWord={deleteWord} onClearAll={() => setWords([])} onExport={handleExport} onFetchPhonetics={fetchPhonetics} onJump={(id) => { setBrowseId(id); setView('browse'); }} t={t} />}
                        {view === 'import' && <ImportView onImport={handleImportData} t={t} existingWords={words} />}
                    </main>

                    {toast && <Toast msg={toast.msg} type={toast.type} onClose={() => setToast(null)} />}
                    <PhoneticModal isOpen={showPhoneticTable} onClose={() => setShowPhoneticTable(false)} />
                    <SettingsModal isOpen={showSettings} onClose={() => setShowSettings(false)} apiKey={apiKey} setApiKey={setApiKey} />
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<WordReviewApp />);
    </script>
</body>
</html>