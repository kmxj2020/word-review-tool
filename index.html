<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>单词复习本 Pro v3.0 (最终完整版)</title>
    
    <!-- 引入核心库 -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        textarea { resize: none; }
        
        @keyframes blob {
            0% { transform: translate(0px, 0px) scale(1); }
            33% { transform: translate(30px, -50px) scale(1.1); }
            66% { transform: translate(-20px, 20px) scale(0.9); }
            100% { transform: translate(0px, 0px) scale(1); }
        }
        .animate-blob { animation: blob 7s infinite; }
        .animation-delay-2000 { animation-delay: 2s; }
        .animation-delay-4000 { animation-delay: 4s; }
        
        .glass-card {
            background: rgba(255, 255, 255, 0.75);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1);
        }
    </style>
</head>
<body class="bg-slate-50 min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        // --- 国际化字典 ---
        const I18N = {
            zh: {
                title: "单词复习本",
                browse: "浏览",
                spelling: "拼写",
                list: "管理",
                import: "导入",
                active: "学习中",
                archived: "已归档",
                empty_browse: "没有待复习的单词 (或已全部归档)",
                empty_spelling: "当前筛选条件下没有单词！",
                no_phonetic: "无音标",
                auto_phonetic: "自动补全音标",
                fetching: "获取中...",
                clear_all: "清空",
                clear_confirm: "确定清空所有单词吗？",
                import_title: "导入数据",
                import_click: "点击上传文件",
                import_desc: "支持 Excel 另存的文本/CSV，或直接粘贴",
                import_ph: "在此直接粘贴内容...",
                import_btn: "开始导入",
                import_success: (n) => `识别成功！发现 ${n} 个单词。\n覆盖词库请点[确定]，追加请点[取消]。`,
                import_fail: "无法识别。请确保格式正确。",
                spelling_setup: "拼写测试配置",
                scope: "复习范围",
                scope_all: "全部活跃",
                scope_fav: "我的收藏",
                scope_new: "未掌握",
                mode: "顺序模式",
                mode_random: "随机乱序",
                mode_seq: "词表顺序",
                hint: "提示模式",
                hint_copy: "抄写模式 (显示单词)",
                hint_blind: "默写模式 (仅看中文)",
                count: "测试数量",
                count_all: "全部",
                start: "开始测试",
                result: "测试完成!",
                correct: "正确",
                wrong: "错误",
                back_setup: "返回设置",
                translate_this: "翻译这个单词",
                type_ph: "输入单词...",
                press_enter_check: "按 Enter 检查",
                press_enter_next: "按 Enter 继续",
                try_again: "再试一次!",
                archive_btn: "归档",
                unarchive_btn: "恢复",
                source: "来源",
                note: "笔记 / 例句",
                key_meaning: "助记 / 核心义",
                key_meaning_ph: "点击下方标签快速添加，自动带词性...",
                quick_pick: "智能提炼:",
                pos_label: "词性",
                export_btn: "导出备份"
            },
            en: {
                title: "Word Review",
                browse: "Browse",
                spelling: "Spelling",
                list: "Manage",
                import: "Import",
                active: "Active",
                archived: "Archived",
                empty_browse: "No words to review (or all archived)",
                empty_spelling: "No words available with current filter!",
                no_phonetic: "No Phonetic",
                auto_phonetic: "Auto Phonetic",
                fetching: "Fetching...",
                clear_all: "Clear All",
                clear_confirm: "Clear all words?",
                import_title: "Import Data",
                import_click: "Upload File",
                import_desc: "Supports Excel text/CSV or Paste below",
                import_ph: "Paste content here...",
                import_btn: "Start Import",
                import_success: (n) => `Success! Found ${n} words.\nClick OK to Overwrite, Cancel to Append.`,
                import_fail: "Failed to parse. Check format.",
                spelling_setup: "Spelling Setup",
                scope: "Scope",
                scope_all: "All Active",
                scope_fav: "Favorites",
                scope_new: "Unmastered",
                mode: "Order",
                mode_random: "Random Shuffle",
                mode_seq: "Sequential",
                hint: "Hint Mode",
                hint_copy: "Copy (Show Word)",
                hint_blind: "Blind (Meaning Only)",
                count: "Count",
                count_all: "All",
                start: "Start Test",
                result: "Test Completed!",
                correct: "Correct",
                wrong: "Wrong",
                back_setup: "Back to Setup",
                translate_this: "TRANSLATE THIS",
                type_ph: "Type word...",
                press_enter_check: "Press Enter to Check",
                press_enter_next: "Press Enter to Continue",
                try_again: "Try again!",
                archive_btn: "Archive",
                unarchive_btn: "Unarchive",
                source: "Source",
                note: "Note / Example",
                key_meaning: "Key Meaning / Memo",
                key_meaning_ph: "Click tags below to add with POS...",
                quick_pick: "Smart Picks:",
                pos_label: "POS",
                export_btn: "Export"
            }
        };

        // --- 图标组件 ---
        const IconBase = ({ children, size = 24, className = "", ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>
        );
        const Icons = {
            BookOpen: (p) => <IconBase {...p}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></IconBase>,
            Check: (p) => <IconBase {...p}><polyline points="20 6 9 17 4 12"/></IconBase>,
            X: (p) => <IconBase {...p}><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></IconBase>,
            RotateCcw: (p) => <IconBase {...p}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></IconBase>,
            Plus: (p) => <IconBase {...p}><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></IconBase>,
            Trash2: (p) => <IconBase {...p}><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></IconBase>,
            Upload: (p) => <IconBase {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></IconBase>,
            Download: (p) => <IconBase {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></IconBase>,
            List: (p) => <IconBase {...p}><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></IconBase>,
            Volume2: (p) => <IconBase {...p}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></IconBase>,
            Edit3: (p) => <IconBase {...p}><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></IconBase>,
            ArrowRight: (p) => <IconBase {...p}><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></IconBase>,
            Shuffle: (p) => <IconBase {...p}><polyline points="16 3 21 3 21 8"/><line x1="4" y1="20" x2="21" y2="3"/><polyline points="21 16 21 21 16 21"/><line x1="15" y1="15" x2="21" y2="21"/><line x1="4" y1="4" x2="9" y2="9"/></IconBase>,
            Star: (p) => <IconBase {...p}><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></IconBase>,
            Eye: (p) => <IconBase {...p}><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></IconBase>,
            FileText: (p) => <IconBase {...p}><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></IconBase>,
            RefreshCw: (p) => <IconBase {...p}><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></IconBase>,
            Keyboard: (p) => <IconBase {...p}><rect x="2" y="4" width="20" height="16" rx="2" ry="2"/><line x1="6" y1="8" x2="6" y2="8"/><line x1="10" y1="8" x2="10" y2="8"/><line x1="14" y1="8" x2="14" y2="8"/><line x1="18" y1="8" x2="18" y2="8"/><line x1="6" y1="12" x2="6" y2="12"/><line x1="10" y1="12" x2="10" y2="12"/><line x1="14" y1="12" x2="14" y2="12"/><line x1="18" y1="12" x2="18" y2="12"/><line x1="6" y1="16" x2="6" y2="16"/><line x1="10" y1="16" x2="14" y2="16"/><line x1="18" y1="16" x2="18" y2="16"/></IconBase>,
            Link: (p) => <IconBase {...p}><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></IconBase>,
            Wand2: (p) => <IconBase {...p}><path d="m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72Z"/><path d="m14 7 3 3"/><path d="M5 6v4"/><path d="M19 14v4"/><path d="M10 2v2"/><path d="M7 8H3"/><path d="M21 16h-4"/><path d="M11 3H9"/></IconBase>,
            Archive: (p) => <IconBase {...p}><polyline points="21 8 21 21 3 21 3 8"/><rect x="1" y="3" width="22" height="5"/><line x1="10" y1="12" x2="14" y2="12"/></IconBase>,
            Globe: (p) => <IconBase {...p}><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></IconBase>,
            PenTool: (p) => <IconBase {...p}><path d="m12 19 7-7 3 3-7 7-3-3z"/><path d="m18 13-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="m2 2 7.586 7.586"/><circle cx="11" cy="11" r="2"/></IconBase>
        };

        // --- 辅助函数 ---
        const extractPOS = (translation) => {
            if (!translation) return { pos: "", cleanTrans: "" };
            // 扫描所有词性
            const posPattern = /^([a-z]{1,5}\.(?:[ \t]*[&,/][ \t]*[a-z]{1,5}\.)?)/i;
            let combinedPos = new Set();
            const lines = translation.split('\n');
            lines.forEach(line => {
                const match = line.trim().match(posPattern);
                if (match) combinedPos.add(match[1]);
            });
            if (combinedPos.size === 0) {
                const startMatch = translation.trim().match(posPattern);
                if (startMatch) combinedPos.add(startMatch[1]);
            }
            // 剥离第一个词性
            let cleanTrans = translation;
            const firstMatch = translation.match(/^([a-z]{1,5}\.(?:[ \t]*[&,/][ \t]*[a-z]{1,5}\.)?)\s*([\s\S]*)/i);
            if (firstMatch) {
                cleanTrans = firstMatch[2]; 
            }
            return { 
                pos: Array.from(combinedPos).join(' '), 
                cleanTrans: cleanTrans || translation 
            };
        };

        // Context-Aware POS Tag Parser
        const parseTranslationTags = (text) => {
            if (!text) return [];
            const splitText = text.replace(/[\n\r；;，,]/g, '|');
            const parts = splitText.split('|').map(s => s.trim()).filter(s => s);
            const tags = [];
            let currentPos = ""; 
            const posStartRegex = /^([a-z]{1,5}\.(?:[ \t]*[&,/][ \t]*[a-z]{1,5}\.)?)\s*(.*)/i;

            parts.forEach(part => {
                const match = part.match(posStartRegex);
                if (match) {
                    currentPos = match[1];
                    const content = match[2];
                    if (content) tags.push(currentPos + " " + content);
                } else {
                    if (currentPos) tags.push(currentPos + " " + part);
                    else tags.push(part);
                }
            });
            return tags;
        };

        const extractPOSForList = (translation) => {
            const tags = parseTranslationTags(translation);
            const uniquePos = [...new Set(tags.map(t => t.pos).filter(Boolean))];
            return uniquePos.join(' ');
        };

        const parseExcelClipboard = (text) => {
            const rows = []; let currentRow = []; let currentCell = ""; let inQuote = false;
            for (let i = 0; i < text.length; i++) {
                const char = text[i]; const nextChar = text[i + 1];
                if (inQuote) {
                    if (char === '"') { if (nextChar === '"') { currentCell += '"'; i++; } else { inQuote = false; } } else { currentCell += char; }
                } else {
                    if (char === '"') { inQuote = true; } 
                    else if (char === '\t') { currentRow.push(currentCell.trim()); currentCell = ""; } 
                    else if (char === '\n' || char === '\r') { if (char === '\r' && nextChar === '\n') i++; currentRow.push(currentCell.trim()); rows.push(currentRow); currentRow = []; currentCell = ""; } 
                    else { currentCell += char; }
                }
            }
            if (currentCell || currentRow.length > 0) { currentRow.push(currentCell.trim()); rows.push(currentRow); }
            return rows;
        };

        // --- 组件 ---
        const GlassButton = ({ onClick, active, iconName, label, className = "" }) => {
            const Icon = Icons[iconName];
            return (
                <button onClick={onClick} className={`flex items-center justify-center px-4 py-2 rounded-xl transition-all duration-300 font-medium text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500/50 ${active ? 'bg-indigo-600/90 text-white shadow-lg shadow-indigo-500/30' : 'bg-white/50 text-gray-600 hover:bg-white/80 hover:text-indigo-600'} ${className}`}>
                    {Icon && <Icon size={16} className={label ? "mr-2" : ""} />} {label}
                </button>
            );
        };

        const DEMO_DATA = [{ id: 1, word: "taught", translation: "v. 教授 (teach 的过去分词)", phonetic: "英 [tɔːt]", mastered: false, isFavorite: false, archived: false, stats: { correct: 0, wrong: 0 }, note: "Eason Chan only <b>taught</b> me how to sing.", source: "Lyrics", keyMeaning: "v. 教授" }];

        function WordReviewApp() {
            const [words, setWords] = useState(() => {
                try {
                    const saved = localStorage.getItem('my_vocab_data_v6_pro');
                    return saved ? JSON.parse(saved) : DEMO_DATA;
                } catch (e) { return DEMO_DATA; }
            });
            const [lang, setLang] = useState('zh'); 
            const [sessionStats, setSessionStats] = useState({ correct: 0, wrong: 0 });
            const [view, setView] = useState('browse'); 
            const [browseIndex, setBrowseIndex] = useState(0);
            const [spellingStep, setSpellingStep] = useState('setup'); 
            const [spellingConfig, setSpellingConfig] = useState({ mode: 'random', count: 5, hint: 'copy', errorMode: 'retry', scope: 'all' });
            const [spellingQueue, setSpellingQueue] = useState([]);
            const [spellingIndex, setSpellingIndex] = useState(0);
            const [spellingInput, setSpellingInput] = useState('');
            const [spellingFeedback, setSpellingFeedback] = useState('idle'); 
            const [importText, setImportText] = useState('');
            const [isFetchingPhonetics, setIsFetchingPhonetics] = useState(false);
            const [listTab, setListTab] = useState('active'); 
            const inputRef = useRef(null);
            const t = I18N[lang];

            const activeWords = words.filter(w => !w.archived);
            const archivedWords = words.filter(w => w.archived);

            useEffect(() => { localStorage.setItem('my_vocab_data_v6_pro', JSON.stringify(words)); }, [words]);
            useEffect(() => { if (view === 'spelling' && spellingStep === 'game' && inputRef.current) inputRef.current.focus(); }, [view, spellingStep, spellingIndex, spellingFeedback]);
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (view === 'browse' && activeWords.length > 0 && document.activeElement.tagName !== 'TEXTAREA' && document.activeElement.tagName !== 'INPUT') {
                        if (e.key === 'ArrowRight') setBrowseIndex((curr) => (curr + 1) % activeWords.length);
                        else if (e.key === 'ArrowLeft') setBrowseIndex((curr) => (curr - 1 + activeWords.length) % activeWords.length);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [view, activeWords.length]);

            const speakWord = (text) => { if (!text) return; const u = new SpeechSynthesisUtterance(text.replace(/\[.*?\]/g, '').trim()); u.lang = 'en-US'; window.speechSynthesis.speak(u); };
            const toggleFavorite = (id) => setWords(prev => prev.map(w => w.id === id ? { ...w, isFavorite: !w.isFavorite } : w));
            const updateWordStats = (id, isCorrect) => {
                setWords(prev => prev.map(w => {
                    if (w.id !== id) return w;
                    const s = w.stats || { correct: 0, wrong: 0 };
                    return { ...w, stats: { correct: s.correct + (isCorrect ? 1 : 0), wrong: s.wrong + (isCorrect ? 0 : 1) } };
                }));
                setSessionStats(prev => ({ correct: prev.correct + (isCorrect ? 1 : 0), wrong: prev.wrong + (isCorrect ? 0 : 1) }));
            };
            const toggleArchive = (id, isArchived) => {
                setWords(prev => prev.map(w => w.id === id ? { ...w, archived: isArchived } : w));
                if (isArchived && view === 'browse') {
                    if (activeWords.length > 1) setBrowseIndex(curr => curr % (activeWords.length - 1));
                    else setBrowseIndex(0);
                }
            };
            const updateKeyMeaning = (id, newMeaning) => {
                setWords(prev => prev.map(w => w.id === id ? { ...w, keyMeaning: newMeaning } : w));
            };

            const fetchPhoneticsForMissing = async () => {
                if (isFetchingPhonetics) return;
                setIsFetchingPhonetics(true);
                const wordsToUpdate = words.filter(w => !w.phonetic || w.phonetic.trim() === '');
                if (wordsToUpdate.length === 0) { alert(t.no_phonetic); setIsFetchingPhonetics(false); return; }
                if (!confirm(`${t.auto_phonetic}?`)) { setIsFetchingPhonetics(false); return; }
                let updatedCount = 0;
                let newWords = [...words];
                for (let i = 0; i < newWords.length; i++) {
                    const w = newWords[i];
                    if (!w.phonetic || w.phonetic.trim() === '') {
                        try {
                            const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${w.word}`);
                            if (res.ok) {
                                const data = await res.json();
                                let ph = "";
                                if (data[0]?.phonetic) ph = data[0].phonetic;
                                else if (data[0]?.phonetics?.length > 0) { const p = data[0].phonetics.find(item => item.text); if (p) ph = p.text; }
                                if (ph) { newWords[i] = { ...w, phonetic: ph }; updatedCount++; }
                            }
                        } catch (e) {}
                        await new Promise(r => setTimeout(r, 50));
                    }
                }
                setWords(newWords);
                setIsFetchingPhonetics(false);
                alert(`Updated ${updatedCount} words.`);
            };

            const startSpelling = () => {
                let queue = [...activeWords];
                if (spellingConfig.scope === 'favorites') queue = queue.filter(w => w.isFavorite);
                if (spellingConfig.scope === 'unmastered') queue = queue.filter(w => !w.mastered);
                if (spellingConfig.mode === 'random') queue = queue.sort(() => Math.random() - 0.5);
                if (spellingConfig.count !== 'all') queue = queue.slice(0, parseInt(spellingConfig.count));
                if (queue.length === 0) { alert(t.empty_spelling); return; }
                setSpellingQueue(queue); setSpellingIndex(0); setSpellingInput(''); setSpellingFeedback('idle'); setSessionStats({ correct: 0, wrong: 0 }); setSpellingStep('game'); setTimeout(() => inputRef.current?.focus(), 100);
            };
            const handleNextSpelling = () => { if (spellingIndex < spellingQueue.length - 1) { setSpellingIndex(prev => prev + 1); setSpellingInput(''); setSpellingFeedback('idle'); } else { setSpellingStep('result'); } };
            const checkSpelling = () => {
                const currentWord = spellingQueue[spellingIndex];
                const inputClean = spellingInput.trim().toLowerCase();
                const targetClean = currentWord.word.trim().toLowerCase();
                if (inputClean === targetClean) { setSpellingFeedback('correct'); speakWord(currentWord.word); updateWordStats(currentWord.id, true); } else { setSpellingFeedback('wrong'); updateWordStats(currentWord.id, false); }
            };
            const handleSpellingKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (spellingFeedback === 'idle') checkSpelling();
                    else if (spellingFeedback === 'correct') handleNextSpelling();
                    else if (spellingFeedback === 'wrong') { if (spellingConfig.errorMode === 'retry') { setSpellingInput(''); setSpellingFeedback('idle'); } else { handleNextSpelling(); } }
                }
            };
            const archiveFromSpelling = () => { const currentWord = spellingQueue[spellingIndex]; toggleArchive(currentWord.id, true); handleNextSpelling(); };

            // --- 导出功能 ---
            const handleExport = () => {
                if (words.length === 0) { alert("没有数据可导出"); return; }
                const now = new Date();
                const timeStr = `${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}`;
                const filename = `单词学习-${timeStr}-${words.length}词.txt`;
                
                let content = "";
                words.forEach(w => {
                    content += `单词：${w.word}\n`;
                    if (w.pos) content += `词性：${w.pos}\n`; // Extra field for human reading, not strictly needed for re-import if we have full translation
                    // Combine pos back into translation for export if needed, or just export raw translation which (hopefully) contains POS
                    // To be safe and support robust re-import, we export the 'clean' translation but prepended with POS if it was stripped, OR just export the raw full translation if available.
                    // But wait, we split POS out. Let's reconstruct or just use translation field (which we kept clean).
                    // Actually, our 'translation' field in state IS the clean one. 'pos' is separate.
                    // For robust re-import using existing logic:
                    // The import logic looks for "单词：" and "释义：". 
                    // Let's reconstruct a full translation string:
                    const fullTrans = w.pos ? `${w.pos} ${w.translation}` : w.translation;
                    content += `释义：${fullTrans}\n`;
                    if (w.phonetic) content += `音标：${w.phonetic}\n`;
                    if (w.note) content += `笔记：${w.note}\n`;
                    if (w.source) content += `来源：${w.source}\n`;
                    if (w.keyMeaning) content += `助记：${w.keyMeaning}\n`;
                    
                    // Data JSON
                    const dataObj = {
                        mastered: w.mastered,
                        isFavorite: w.isFavorite,
                        archived: w.archived,
                        stats: w.stats
                    };
                    content += `数据：${JSON.stringify(dataObj)}\n`;
                    content += `\n`;
                });

                const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
                const url = URL.createObjectURL(blob);
                const link = document.createElement("a");
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            // --- 导入功能 (升级版：支持数据恢复) ---
            const parseImportData = () => {
                if (!importText.trim()) return;
                let newWords = []; const text = importText.trim();
                
                // 1. 尝试 Text Block 模式 (包含 "单词：" )
                if (text.includes('单词：')) {
                    const blocks = text.split(/单词：/).filter(b => b.trim().length > 0);
                    newWords = blocks.map((block, index) => {
                        const lines = block.split('\n');
                        const word = lines[0].trim(); // First line is word (since we split by "单词：")
                        
                        // Helper to extract field by label
                        const extractField = (label) => {
                            // Regex: Label：(content) until next Label or End
                            // Known labels: 释义, 音标, 笔记, 来源, 助记, 数据, 词性
                            const regex = new RegExp(`${label}：([\\s\\S]*?)(?=\\n(?:释义|音标|笔记|来源|助记|数据|词性|单词)：|$)`);
                            const match = block.match(regex);
                            return match ? match[1].trim() : "";
                        };

                        const translation = extractField('释义');
                        const phonetic = extractField('音标');
                        const note = extractField('笔记');
                        const source = extractField('来源');
                        const keyMeaning = extractField('助记');
                        const dataJson = extractField('数据');
                        
                        // Parse Data JSON if exists
                        let meta = { mastered: false, isFavorite: false, archived: false, stats: { correct: 0, wrong: 0 } };
                        if (dataJson) {
                            try { meta = { ...meta, ...JSON.parse(dataJson) }; } catch(e) {}
                        }
                        
                        if (!word) return null;

                        // Re-extract POS from translation to ensure consistency
                        const { pos, cleanTrans } = extractPOS(translation);

                        return { 
                            id: Date.now() + index + Math.random(), 
                            word, 
                            translation: cleanTrans || "暂无", 
                            phonetic, 
                            pos, 
                            note, 
                            source, 
                            keyMeaning, 
                            ...meta 
                        };
                    }).filter(w => w !== null);
                } 
                // 2. 尝试 Excel 模式 (没有 "单词：" 标签)
                else {
                    const rows = parseExcelClipboard(text);
                    newWords = rows.map((cols, index) => {
                        if (cols.length < 2) return null;
                        const word = cols[0]?.trim() || "Unknown";
                        const rawTrans = cols[1]?.trim() || "";
                        const phonetic = cols[2]?.trim() || "";
                        const mastered = (cols[3]?.trim().toLowerCase() === 'yes');
                        const note = cols[4]?.trim() || "";
                        const { pos, cleanTrans } = extractPOS(rawTrans);
                        return { id: Date.now() + index + Math.random(), word, translation: cleanTrans, phonetic, pos, mastered, note, source: "Excel", keyMeaning: "", isFavorite: false, archived: false, stats: { correct: 0, wrong: 0 } };
                    }).filter(w => w !== null);
                }
                
                if (newWords.length > 0) {
                    if (confirm(t.import_success(newWords.length))) setWords(newWords); else { const exist = new Set(words.map(w => w.word.toLowerCase())); const unique = newWords.filter(w => !exist.has(w.word.toLowerCase())); setWords([...words, ...unique]); }
                    setImportText(''); setView('list');
                } else { alert(t.import_fail); }
            };

            const handleFileUpload = (e) => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (evt) => setImportText(evt.target.result); reader.readAsText(file); };

            // --- Renderers ---
            const renderBrowse = () => {
                if (activeWords.length === 0) return <div className="text-center mt-20 text-gray-500">{t.empty_browse}</div>;
                const card = activeWords[browseIndex] || activeWords[0];
                const smartTags = parseTranslationTags(card.translation);
                const quickPicks = smartTags; // Re-use the parsed tags directly

                return (
                    <div className="h-full flex items-center justify-center relative px-4">
                        <button onClick={() => setBrowseIndex((curr) => (curr - 1 + activeWords.length) % activeWords.length)} className="hidden md:block absolute left-0 p-4 text-gray-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-full transition"><Icons.ArrowRight className="rotate-180" size={32}/></button>
                        <button onClick={() => setBrowseIndex((curr) => (curr + 1) % activeWords.length)} className="hidden md:block absolute right-0 p-4 text-gray-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-full transition"><Icons.ArrowRight size={32}/></button>
                        <div className="w-full max-w-2xl glass-card rounded-3xl p-8 md:p-12 relative flex flex-col justify-between min-h-[600px]">
                            <div className="flex justify-between items-start mb-6">
                                <div className="text-sm font-mono text-gray-400 bg-gray-100 px-3 py-1 rounded-full">{activeWords.indexOf(card) + 1} / {activeWords.length}</div>
                                <div className="flex space-x-2">
                                    <button onClick={() => toggleFavorite(card.id)} className={`p-2 rounded-full transition hover:bg-gray-100 ${card.isFavorite ? 'text-yellow-400' : 'text-gray-300'}`}><Icons.Star fill={card.isFavorite ? "currentColor" : "none"} /></button>
                                    <button onClick={() => speakWord(card.word)} className="p-2 rounded-full text-indigo-500 hover:bg-indigo-50 transition"><Icons.Volume2 /></button>
                                    <button onClick={() => toggleArchive(card.id, true)} className="p-2 rounded-full text-gray-400 hover:text-red-500 hover:bg-red-50 transition" title={t.archive_btn}><Icons.Archive /></button>
                                </div>
                            </div>
                            <div className="text-center mb-6">
                                <h2 className="text-5xl md:text-6xl font-black text-gray-800 mb-2 tracking-tight">{card.word}</h2>
                                <div className="text-xl text-gray-400 font-mono mb-4 h-6">{card.phonetic || <span className="text-xs bg-gray-100 px-2 py-1 rounded">{t.no_phonetic}</span>}</div>
                                {card.pos && (
                                    <div className="flex justify-center flex-wrap gap-2 mb-2">
                                        {card.pos.split(' ').map((p, i) => (
                                            <span key={i} className="bg-indigo-100 text-indigo-700 px-2 py-0.5 rounded-md text-sm font-bold font-mono">{p}</span>
                                        ))}
                                    </div>
                                )}
                            </div>
                            <div className="bg-white/60 rounded-xl p-4 border border-indigo-100 shadow-sm mb-4">
                                <div className="flex items-center justify-between mb-2">
                                    <div className="text-xs font-bold text-indigo-600 uppercase flex items-center"><Icons.PenTool size={12} className="mr-1"/> {t.key_meaning}</div>
                                </div>
                                <textarea className="w-full bg-transparent border-b border-dashed border-gray-300 focus:border-indigo-500 focus:outline-none text-lg font-bold text-gray-800 placeholder-gray-300 py-1" rows="1" placeholder={t.key_meaning_ph} value={card.keyMeaning || ""} onChange={(e) => updateKeyMeaning(card.id, e.target.value)}></textarea>
                                <div className="mt-3 flex flex-wrap gap-2">
                                    <span className="text-xs text-gray-400 mr-1 self-center">{t.quick_pick}</span>
                                    {smartTags.map((tag, idx) => {
                                        const fullTagText = tag; 
                                        const currentVal = card.keyMeaning || "";
                                        const parts = currentVal.split(/[,;，；]/).map(s => s.trim());
                                        const isActive = parts.includes(fullTagText);
                                        return (
                                            <button key={idx} onClick={() => { let newParts; if (isActive) { newParts = parts.filter(p => p !== fullTagText); } else { newParts = [...parts.filter(Boolean), fullTagText]; } updateKeyMeaning(card.id, newParts.join("；")); }} className={`text-xs px-2 py-1 rounded border transition active:scale-95 flex items-center ${isActive ? 'bg-indigo-600 border-indigo-600 text-white shadow-md' : 'bg-white border-indigo-100 text-indigo-600 hover:bg-indigo-50 hover:border-indigo-300'}`} >
                                                {tag} {isActive && <span className="ml-1 opacity-50">×</span>}
                                            </button>
                                        );
                                    })}
                                </div>
                            </div>
                            <div className="w-full h-px bg-gray-100 mb-4"></div>
                            <h3 className="text-lg text-gray-500 font-medium mb-4 px-2 whitespace-pre-wrap leading-relaxed">{card.translation}</h3>
                            <div className="space-y-2 text-left">
                                {card.note && (<div className="bg-indigo-50/50 rounded-xl p-3 border border-indigo-100/50"><div className="text-xs font-bold text-indigo-400 uppercase mb-1 flex items-center"><Icons.FileText size={12} className="mr-1"/> {t.note}</div><div className="text-gray-700 text-sm leading-relaxed whitespace-pre-wrap" dangerouslySetInnerHTML={{__html: card.note}}></div></div>)}
                                {card.source && (<div className="flex items-center justify-end text-xs text-gray-400 mt-1"><Icons.Link size={10} className="mr-1"/> <span className="truncate max-w-xs" title={card.source}>{t.source}: {card.source}</span></div>)}
                            </div>
                        </div>
                    </div>
                );
            };

            const renderSpellingComp = () => {
                 if (spellingStep === 'setup') return renderSpelling();
                 if (spellingStep === 'result') return renderSpelling();
                 const card = spellingQueue[spellingIndex];
                 const isCorrect = spellingFeedback === 'correct';
                 const isWrong = spellingFeedback === 'wrong';
                 return (
                    <div className="max-w-xl mx-auto">
                        <div className="flex justify-between items-center mb-6 px-4">
                            <button onClick={() => setSpellingStep('setup')} className="text-gray-500 hover:text-gray-800 text-sm font-medium">Exit</button>
                            <div className="flex items-center space-x-4">
                                <button onClick={archiveFromSpelling} className="text-gray-400 hover:text-red-500 flex items-center text-xs bg-white/50 px-2 py-1 rounded border border-gray-200"><Icons.Archive size={14} className="mr-1"/>{t.archive_btn}</button>
                                <div className="flex space-x-3 text-sm font-mono"><span className="text-green-600 font-bold">✓ {sessionStats.correct}</span><span className="text-red-500 font-bold">✕ {sessionStats.wrong}</span></div>
                            </div>
                        </div>
                        <div className="p-8 md:p-10 relative overflow-hidden glass-card rounded-3xl">
                            <div className="absolute top-0 left-0 h-1.5 bg-indigo-100 w-full"><div className="h-full bg-indigo-500 transition-all duration-500" style={{width: `${((spellingIndex)/spellingQueue.length)*100}%`}}></div></div>
                            <div className="mb-8 text-center space-y-4 min-h-[100px]">
                                <div className="text-gray-400 text-xs uppercase tracking-widest font-bold">{t.translate_this}</div>
                                <h3 className="text-3xl text-gray-800 font-bold leading-relaxed flex flex-col items-center">
                                    {card.keyMeaning ? <span className="text-indigo-900">{card.keyMeaning}</span> : card.translation.split('\n')[0]}
                                    {!card.keyMeaning && extractPOSForList(card.translation) && <span className="mt-1 text-xs bg-indigo-50 text-indigo-400 px-2 py-0.5 rounded font-mono">{extractPOSForList(card.translation)}</span>}
                                </h3>
                                {card.keyMeaning && <div className="text-sm text-gray-400 line-clamp-1">{card.translation.split('\n')[0]}</div>}
                                <div className={`transition-all duration-300 overflow-hidden ${spellingConfig.hint === 'copy' || isCorrect || isWrong ? 'opacity-100 max-h-24' : 'opacity-0 max-h-0'}`}>
                                    <div className="text-5xl font-black text-indigo-600 tracking-wider font-mono mt-4">{card.word}</div>
                                </div>
                                <div className="text-xs text-gray-400 mt-2 italic line-clamp-2">
                                    {card.note && <span dangerouslySetInnerHTML={{__html: card.note.replace(/<b>.*?<\/b>/g, '___').substring(0, 100) + '...'}}></span>}
                                </div>
                            </div>
                            <div className="relative mb-6">
                                <input ref={inputRef} type="text" value={spellingInput} onChange={(e) => setSpellingInput(e.target.value)} onKeyDown={handleSpellingKeyDown} readOnly={isCorrect} placeholder={t.type_ph} className={`w-full bg-gray-50/50 border-2 text-center text-4xl font-black py-6 rounded-2xl focus:outline-none transition-all ${isCorrect ? 'border-green-500 text-green-600 bg-green-50/30 ring-2 ring-green-200' : ''} ${isWrong ? 'border-red-500 text-red-500 bg-red-50/30 animate-pulse' : 'border-gray-200 focus:border-indigo-500 text-gray-800'}`} autoComplete="off" spellCheck="false" />
                                <div className="absolute right-4 top-1/2 transform -translate-y-1/2 text-gray-400 pointer-events-none opacity-50"><Icons.Keyboard size={24} /></div>
                            </div>
                            <div className="text-center h-8">
                                {isCorrect && <div className="text-green-600 font-bold text-sm animate-bounce">{t.press_enter_next}</div>}
                                {isWrong && spellingConfig.errorMode === 'retry' && <div className="text-red-500 text-sm font-bold">{t.try_again}</div>}
                                {spellingFeedback === 'idle' && <div className="text-gray-400 text-xs">{t.press_enter_check}</div>}
                            </div>
                        </div>
                    </div>
                 );
            };

            const renderSpelling = () => {
                if (spellingStep === 'setup') {
                    return (
                        <div className="max-w-lg mx-auto p-8 glass-card rounded-3xl">
                            <h2 className="text-2xl font-bold text-gray-800 mb-6 flex items-center"><Icons.Edit3 className="mr-2 text-indigo-500" /> {t.spelling_setup}</h2>
                            <div className="space-y-6">
                                <div>
                                    <label className="block text-sm font-bold text-gray-600 mb-2">{t.mode}</label>
                                    <div className="grid grid-cols-2 gap-3">
                                        <button onClick={() => setSpellingConfig({...spellingConfig, mode: 'random'})} className={`p-3 rounded-xl border text-left ${spellingConfig.mode === 'random' ? 'bg-indigo-50 border-indigo-500 ring-1 ring-indigo-500' : 'border-gray-200'}`}><div className="font-bold text-indigo-900">{t.mode_random}</div></button>
                                        <button onClick={() => setSpellingConfig({...spellingConfig, mode: 'sequential'})} className={`p-3 rounded-xl border text-left ${spellingConfig.mode === 'sequential' ? 'bg-indigo-50 border-indigo-500 ring-1 ring-indigo-500' : 'border-gray-200'}`}><div className="font-bold text-indigo-900">{t.mode_seq}</div></button>
                                    </div>
                                </div>
                                <div>
                                    <label className="block text-sm font-bold text-gray-600 mb-2">{t.scope}</label>
                                    <div className="grid grid-cols-3 gap-2">
                                        {['all', 'favorites', 'unmastered'].map(scope => (
                                            <button key={scope} onClick={() => setSpellingConfig({...spellingConfig, scope})} className={`py-2 px-1 rounded-lg text-sm border ${spellingConfig.scope === scope ? 'bg-indigo-50 border-indigo-500 text-indigo-700 font-bold' : 'border-gray-200 text-gray-500'}`}>{scope === 'all' ? t.scope_all : scope === 'favorites' ? t.scope_fav : t.scope_new}</button>
                                        ))}
                                    </div>
                                </div>
                                <div>
                                    <label className="block text-sm font-bold text-gray-600 mb-2">{t.hint}</label>
                                    <div className="grid grid-cols-2 gap-3">
                                        <button onClick={() => setSpellingConfig({...spellingConfig, hint: 'copy'})} className={`p-3 rounded-xl border text-left ${spellingConfig.hint === 'copy' ? 'bg-indigo-50 border-indigo-500 ring-1 ring-indigo-500' : 'border-gray-200'}`}><div className="font-bold text-indigo-900">{t.hint_copy}</div></button>
                                        <button onClick={() => setSpellingConfig({...spellingConfig, hint: 'none'})} className={`p-3 rounded-xl border text-left ${spellingConfig.hint === 'none' ? 'bg-indigo-50 border-indigo-500 ring-1 ring-indigo-500' : 'border-gray-200'}`}><div className="font-bold text-indigo-900">{t.hint_blind}</div></button>
                                    </div>
                                </div>
                                <div>
                                    <label className="block text-sm font-bold text-gray-600 mb-2">{t.count}</label>
                                    <div className="flex items-center space-x-4">
                                        {[5, 10, 20, 'all'].map(n => (
                                            <button key={n} onClick={() => setSpellingConfig({...spellingConfig, count: n})} className={`w-10 h-10 rounded-full flex items-center justify-center font-bold text-sm transition ${spellingConfig.count === n ? 'bg-indigo-600 text-white shadow-lg shadow-indigo-300' : 'bg-white border border-gray-200 text-gray-500'}`}>{n === 'all' ? t.count_all : n}</button>
                                        ))}
                                    </div>
                                </div>
                                <button onClick={startSpelling} className="w-full py-4 bg-indigo-600 hover:bg-indigo-700 text-white font-bold rounded-xl shadow-xl shadow-indigo-200 transition transform active:scale-95">{t.start}</button>
                            </div>
                        </div>
                    );
                }
                if (spellingStep === 'result') {
                    return (
                        <div className="max-w-md mx-auto p-10 text-center glass-card rounded-3xl">
                            <div className="w-24 h-24 bg-indigo-100 text-indigo-600 rounded-full flex items-center justify-center mx-auto mb-6"><Icons.Check size={48} strokeWidth={3} /></div>
                            <h2 className="text-3xl font-bold text-gray-800 mb-2">{t.result}</h2>
                            <div className="grid grid-cols-2 gap-6 mb-8 mt-8">
                                <div className="bg-green-50 p-4 rounded-2xl border border-green-100"><div className="text-4xl font-bold text-green-600">{sessionStats.correct}</div><div className="text-xs font-bold text-green-800/50 uppercase mt-1">{t.correct}</div></div>
                                <div className="bg-red-50 p-4 rounded-2xl border border-red-100"><div className="text-4xl font-bold text-red-500">{sessionStats.wrong}</div><div className="text-xs font-bold text-red-800/50 uppercase mt-1">{t.wrong}</div></div>
                            </div>
                            <button onClick={() => setSpellingStep('setup')} className="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold rounded-xl transition">{t.back_setup}</button>
                        </div>
                    );
                }
                return null;
            };

            const renderList = () => {
                const displayWords = listTab === 'active' ? activeWords : archivedWords;
                return (
                    <div className="overflow-hidden flex flex-col max-h-[80vh] glass-card rounded-3xl">
                        <div className="p-4 border-b border-gray-200/50 bg-white/40 flex justify-between items-center">
                            <div className="flex space-x-4">
                                <button onClick={() => setListTab('active')} className={`text-sm font-bold pb-1 border-b-2 transition ${listTab === 'active' ? 'text-indigo-600 border-indigo-600' : 'text-gray-400 border-transparent'}`}>{t.active} ({activeWords.length})</button>
                                <button onClick={() => setListTab('archived')} className={`text-sm font-bold pb-1 border-b-2 transition ${listTab === 'archived' ? 'text-indigo-600 border-indigo-600' : 'text-gray-400 border-transparent'}`}>{t.archived} ({archivedWords.length})</button>
                            </div>
                            <div className="flex items-center space-x-2">
                                <button onClick={handleExport} className="text-xs flex items-center px-3 py-1.5 bg-green-50 text-green-600 rounded-lg hover:bg-green-100 transition font-bold border border-green-100 mr-2">
                                    <Icons.Download className="mr-1" size={12}/>{t.export_btn}
                                </button>
                                <button onClick={fetchPhoneticsForMissing} disabled={isFetchingPhonetics} className="text-xs flex items-center px-3 py-1.5 bg-indigo-50 text-indigo-600 rounded-lg hover:bg-indigo-100 transition disabled:opacity-50">
                                    {isFetchingPhonetics ? <Icons.RefreshCw className="animate-spin mr-1" size={12}/> : <Icons.Wand2 className="mr-1" size={12}/>}
                                    {isFetchingPhonetics ? t.fetching : t.auto_phonetic}
                                </button>
                                <button onClick={() => {if(confirm(t.clear_confirm)) setWords([])}} className="text-xs text-red-400 hover:text-red-600 flex items-center"><Icons.Trash2 size={12} className="mr-1"/>{t.clear_all}</button>
                            </div>
                        </div>
                        <div className="overflow-y-auto flex-1">
                            <table className="w-full text-left border-collapse">
                                <thead className="sticky top-0 bg-white/90 backdrop-blur-sm z-10 text-gray-500 text-xs uppercase tracking-wider">
                                    <tr><th className="p-4">Word</th><th className="p-4">Meaning</th><th className="p-4 text-right">Action</th></tr>
                                </thead>
                                <tbody className="divide-y divide-gray-100/50 text-sm text-gray-700">
                                    {displayWords.map(word => (
                                        <tr key={word.id} className="hover:bg-indigo-50/30 transition">
                                            <td className="p-4">
                                                <div className="font-bold">{word.word}</div>
                                                <div className="flex items-center mt-1">
                                                    {word.pos && <span className="text-xs bg-indigo-50 text-indigo-500 px-1.5 py-0.5 rounded mr-2 font-mono">{word.pos}</span>}
                                                    <span className="text-xs text-gray-400 font-mono">{word.phonetic || "-"}</span>
                                                </div>
                                            </td>
                                            <td className="p-4 text-gray-600 max-w-xs truncate" title={word.translation}>
                                                {word.keyMeaning ? <span className="text-indigo-900 font-medium mr-2">{word.keyMeaning}</span> : null}
                                                <span className="text-gray-500">{word.translation}</span>
                                            </td>
                                            <td className="p-4 text-right flex justify-end space-x-2">
                                                <button onClick={() => toggleArchive(word.id, !word.archived)} className={`text-xs px-2 py-1 rounded border ${word.archived ? 'border-green-200 text-green-600 hover:bg-green-50' : 'border-gray-200 text-gray-400 hover:text-red-500 hover:bg-red-50'}`}>
                                                    {word.archived ? t.unarchive_btn : t.archive_btn}
                                                </button>
                                                <button onClick={() => setWords(words.filter(w => w.id !== word.id))} className="text-gray-300 hover:text-red-500"><Icons.Trash2 size={16} /></button>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </div>
                );
            };

            const renderImport = () => (
                <div className="p-8 max-w-2xl mx-auto glass-card rounded-3xl">
                    <h3 className="text-xl font-bold text-gray-800 mb-6 flex items-center"><Icons.Upload className="mr-2 text-indigo-500" /> {t.import_title}</h3>
                    <div className="space-y-6">
                        <div className="border-2 border-dashed border-indigo-200 bg-indigo-50/30 rounded-2xl p-8 text-center relative hover:bg-indigo-50/60 transition">
                            <input type="file" accept=".csv,.txt" onChange={handleFileUpload} className="absolute inset-0 w-full h-full opacity-0 cursor-pointer" />
                            <div className="w-16 h-16 bg-indigo-100 text-indigo-500 rounded-full flex items-center justify-center mx-auto mb-4"><Icons.FileText size={32} /></div>
                            <h4 className="font-bold text-indigo-900 mb-1">{t.import_click}</h4>
                            <p className="text-xs text-gray-400">{t.import_desc}</p>
                        </div>
                        <textarea value={importText} onChange={(e) => setImportText(e.target.value)} placeholder={t.import_ph} className="w-full h-32 p-4 border border-gray-200 rounded-xl bg-white/50 focus:ring-2 focus:ring-indigo-500 font-mono text-xs"></textarea>
                        <button onClick={parseImportData} disabled={!importText} className="w-full py-3 bg-indigo-600 text-white rounded-xl font-bold shadow-lg hover:bg-indigo-700 transition disabled:opacity-50">{t.import_btn}</button>
                    </div>
                </div>
            );

            return (
                <div className="bg-gradient-to-br from-blue-50 to-indigo-100 flex flex-col min-h-screen">
                    <div className="fixed top-0 left-0 w-full h-full overflow-hidden pointer-events-none -z-10">
                        <div className="absolute top-0 left-1/4 w-96 h-96 bg-purple-300 rounded-full mix-blend-multiply filter blur-3xl opacity-30 animate-blob"></div>
                        <div className="absolute top-0 right-1/4 w-96 h-96 bg-yellow-300 rounded-full mix-blend-multiply filter blur-3xl opacity-30 animate-blob animation-delay-2000"></div>
                    </div>
                    <header className="px-6 py-4 flex justify-between items-center z-10 max-w-5xl mx-auto w-full">
                        <div className="glass-card rounded-3xl px-2 py-2 flex space-x-1">
                            {[{ id: 'browse', iconName: 'Eye', label: t.browse }, { id: 'spelling', iconName: 'Edit3', label: t.spelling }, { id: 'list', iconName: 'List', label: t.list }, { id: 'import', iconName: 'Upload', label: t.import }].map(tab => (
                                <GlassButton key={tab.id} active={view === tab.id} onClick={() => setView(tab.id)} iconName={tab.iconName} label={tab.label} />
                            ))}
                        </div>
                        <button onClick={() => setLang(l => l === 'zh' ? 'en' : 'zh')} className="glass-card p-2 rounded-full hover:bg-white/80 transition text-indigo-600 font-bold flex items-center">
                            <Icons.Globe size={20} className="mr-1" /> {lang.toUpperCase()}
                        </button>
                    </header>
                    <main className="flex-1 max-w-5xl mx-auto w-full p-4 md:p-6 flex flex-col relative z-0">
                        {view === 'browse' && renderBrowse()}
                        {view === 'spelling' && renderSpellingComp()}
                        {view === 'list' && renderList()}
                        {view === 'import' && renderImport()}
                    </main>
                </div>
            );
        }
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<WordReviewApp />);
    </script>
</body>
</html>
